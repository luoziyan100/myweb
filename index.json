[{"content":"这是王垠《如何掌握所有编程语言》读后感\n这是将王垠文章中的思想转化为一份可执行的、终极的学习蓝图。\n这份指南的目的不是让你记住一万个零散的知识点，而是为你构建一个“心智框架”。当你遇到任何编程语言（无论是现存的还是未来的）时，你都可以将它的特性“挂”在这个框架的相应位置，从而瞬间理解它的设计哲学与应用场景。\n我们将编程语言的所有特性，按照从具体到抽象，从微观到宏观的层次，分为五个核心层级。\n如何学习编程语言的所有特性：一份终极指南 核心思想：成为特性的主人，而非语言的奴隶 忘记“学习Python”或“学习Java”。你的目标是学习“变量”、“类型系统”、“并发模型”这些永恒的概念。一旦掌握了概念本身，任何语言都只是其特定语法（方言）的表达。\n学习方法论：锚定 -\u0026gt; 抽象 -\u0026gt; 对比 -\u0026gt; 实现 对于下述每一项特性，都遵循此四步法：\n锚定 (Anchor)：选择一门你熟悉的“合理语言”（如Python, Java, C），首先通过它学会该特性的用法。 抽象 (Abstract)：用你自己的话，不依赖任何特定语法，描述这个特性的本质目的。它解决了什么根本问题？比如，“函数”是为了“封装可复用的代码块，并给它命名”。 对比 (Contrast)：立即去查找2-3门不同设计哲学的语言，看它们是如何实现同一个特性的。比如，对比Python、Java、C语言的for循环。这个过程会剥离语法的外壳，让你直达特性的核心。 实现 (Implement)：这是大师级的最后一步。尝试用你已知的简单特性，去模拟实现一个更高级的特性。比如，在C语言里用struct和函数指针模拟一个简单的“对象”。这个过程会让你彻底内化该特性。 编程语言特性的全景蓝图 (The Grand Blueprint) 第一层：执行的基石 (The Bedrock of Execution) 这是所有编程语言都必须具备的、最基础的“原子”特性。它们是构建一切逻辑的砖块。\n变量与赋值 (Variables \u0026amp; Assignment) 本质：为数据命名，并将其存储在内存中。 探索点：作用域（全局、局部、块级）、生命周期。 基础数据类型 (Primitive Data Types) 本质：语言内建的、最基本的数据种类。 探索点：整数（不同位宽）、浮点数（精度问题）、布尔值、字符。 运算符 (Operators) 本质：对数据进行操作的符号。 探索点：算术、比较、逻辑、位运算；运算符优先级和结合性。 控制流 (Control Flow) 本质：决定代码执行顺序的结构。 探索点：条件分支 (if/else/switch)、循环 (for/while/do-while)、跳转 (break/continue/goto)、返回 (return)。 函数/过程 (Functions/Procedures) 本质：代码的封装、抽象与复用。 探索点：参数传递（值传递 vs. 引用传递）、返回值、递归。 第二层：数据的组织 (The Organization of Data) 当单个数据不足以表达复杂信息时，我们需要将它们组织起来。\n复合数据结构 (Compound Data Structures) 本质：将多个数据组织成一个单元的机制。 探索点：数组/列表（连续内存）、记录/结构体/元组（字段集合）、字典/哈希表/映射（键值对）、集合（唯一元素）。 输入/输出 (I/O) 本质：程序与外部世界（控制台、文件、网络）交互的方式。 探索点：流的概念、文件读写、标准输入/输出/错误。 错误处理 (Error Handling) 本质：应对程序运行时意外情况的机制。 探索点：返回值/错误码 (C)、异常处理 (try/catch/finally) (Java/Python)、Result/Option类型 (Rust)。 第三层：代码的范式 (The Paradigms of Code) 这是关于如何大规模组织代码、管理复杂度的“设计哲学”。\n面向对象编程 (OOP - Object-Oriented Programming) 本质：将数据和操作数据的函数捆绑为“对象”。 探索点： 封装 (Encapsulation)：隐藏内部实现细节。 继承 (Inheritance)：基于现有类创建新类。 多态 (Polymorphism)：不同对象对同一消息的不同响应。 类 (Class) vs. 对象 (Object)、构造函数、方法、访问修饰符 (public/private)。 函数式编程 (FP - Functional Programming) 本质：将计算视为数学函数的求值，避免状态变化和可变数据。 探索点： 纯函数 (Pure Functions)：无副作用。 不可变性 (Immutability)：数据创建后不能修改。 高阶函数 (Higher-Order Functions)：函数可以作为参数或返回值。 Lambda函数/闭包 (Closures)。 模块化与命名空间 (Modularity \u0026amp; Namespaces) 本质：将代码分割成独立、可复用的逻辑单元，并避免命名冲突。 探索点：import/export、包管理、库。 第四层：与机器的对话 (The Conversation with the Machine) 这些特性深刻地影响着程序的性能、安全性以及与硬件的交互方式。\n类型系统 (Type System) 本质：一套用于保证数据类型正确性的规则。 探索点： 静态类型 vs. 动态类型：编译时检查还是运行时检查？ 强类型 vs. 弱类型：是否允许隐式类型转换？ 类型推导 (Type Inference)：编译器自动推断类型。 泛型/模板 (Generics/Templates)：编写不依赖于具体类型的代码。 内存管理 (Memory Management) 本质：程序如何申请、使用和释放内存。 探索点： 栈 (Stack) vs. 堆 (Heap) 分配。 手动管理 (malloc/free) (C)。 自动垃圾回收 (GC) (Java, Python, JS)。 所有权与借用 (Ownership \u0026amp; Borrowing) (Rust)。 并发/并行模型 (Concurrency/Parallelism Model) 本质：同时处理多个任务的机制。 探索点：线程、进程、锁、async/await、协程 (Goroutines)、Actor模型。 第五层：语言的超能力 (The Superpowers of the Language) 这些是更高级的、甚至能让语言“自己操作自己”的特性。\n元编程 (Metaprogramming) 本质：编写能够操作或生成其他代码的代码。 探索点：宏 (Lisp, Rust)、注解/装饰器 (Java, Python)、反射 (Java)。 外部函数接口 (Foreign Function Interface - FFI) 本质：一种语言调用另一种语言（通常是C）编写的代码的能力。 标准库 (The Standard Library) 本质：语言自带的一套预先写好的、可直接使用的功能集合。 探索点：其广度、设计哲学和易用性，是语言“生态”的关键部分。 结论：成为语言架构师\n当你按照这个蓝图，逐个攻克这些核心特性，并用“四步法”将其内化于心时，你就不再是一个“Python程序员”或“Java程序员”。你成了一个通晓编程语言设计原理的架构师。\n面对任何一门新语言，你都能在五分钟内看透它的本质：它的类型系统是静态还是动态？它的内存管理是GC还是手动？它的并发模型是什么？然后，你就可以迅速地将你脑中关于这些特性的知识，映射到它那套新的语法之上，立即上手，并写出符合其设计哲学的、高质量的代码。\n这就是学会所有编程语言的真正奥秘。\n","permalink":"https://luoziyan100.github.io/myweb/posts/2025/9%E6%9C%88%E4%BB%BD/2025-09-06-%E6%80%8E%E4%B9%88%E5%AD%A6%E4%B9%A0%E7%BC%96%E7%A8%8B/","summary":"\u003cp\u003e\u003cstrong\u003e这是王垠《如何掌握所有编程语言》读后感\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e这是将王垠文章中的思想转化为一份可执行的、终极的学习蓝图。\u003c/p\u003e\n\u003cp\u003e这份指南的目的不是让你记住一万个零散的知识点，而是为你构建一个“心智框架”。当你遇到任何编程语言（无论是现存的还是未来的）时，你都可以将它的特性“挂”在这个框架的相应位置，从而瞬间理解它的设计哲学与应用场景。\u003c/p\u003e\n\u003cp\u003e我们将编程语言的所有特性，按照从具体到抽象，从微观到宏观的层次，分为五个核心层级。\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"如何学习编程语言的所有特性一份终极指南\"\u003e\u003cstrong\u003e如何学习编程语言的所有特性：一份终极指南\u003c/strong\u003e\u003c/h3\u003e\n\u003ch4 id=\"核心思想成为特性的主人而非语言的奴隶\"\u003e\u003cstrong\u003e核心思想：成为特性的主人，而非语言的奴隶\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e忘记“学习Python”或“学习Java”。你的目标是学习“变量”、“类型系统”、“并发模型”这些永恒的概念。一旦掌握了概念本身，任何语言都只是其特定语法（方言）的表达。\u003c/p\u003e\n\u003ch4 id=\"学习方法论锚定---抽象---对比---实现\"\u003e\u003cstrong\u003e学习方法论：锚定 -\u0026gt; 抽象 -\u0026gt; 对比 -\u0026gt; 实现\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e对于下述每一项特性，都遵循此四步法：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e锚定 (Anchor)\u003c/strong\u003e：选择一门你熟悉的“合理语言”（如Python, Java, C），首先通过它学会该特性的\u003cstrong\u003e用法\u003c/strong\u003e。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e抽象 (Abstract)\u003c/strong\u003e：用你自己的话，不依赖任何特定语法，描述这个特性的\u003cstrong\u003e本质目的\u003c/strong\u003e。它解决了什么根本问题？比如，“函数”是为了“封装可复用的代码块，并给它命名”。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e对比 (Contrast)\u003c/strong\u003e：立即去查找2-3门不同设计哲学的语言，看它们是如何实现\u003cstrong\u003e同一个特性\u003c/strong\u003e的。比如，对比Python、Java、C语言的\u003ccode\u003efor\u003c/code\u003e循环。这个过程会剥离语法的外壳，让你直达特性的核心。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e实现 (Implement)\u003c/strong\u003e：这是大师级的最后一步。尝试用你已知的简单特性，去\u003cstrong\u003e模拟实现\u003c/strong\u003e一个更高级的特性。比如，在C语言里用\u003ccode\u003estruct\u003c/code\u003e和函数指针模拟一个简单的“对象”。这个过程会让你彻底内化该特性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch3 id=\"编程语言特性的全景蓝图-the-grand-blueprint\"\u003e\u003cstrong\u003e编程语言特性的全景蓝图 (The Grand Blueprint)\u003c/strong\u003e\u003c/h3\u003e\n\u003ch4 id=\"第一层执行的基石-the-bedrock-of-execution\"\u003e\u003cstrong\u003e第一层：执行的基石 (The Bedrock of Execution)\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e这是所有编程语言都必须具备的、最基础的“原子”特性。它们是构建一切逻辑的砖块。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e变量与赋值 (Variables \u0026amp; Assignment)\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e本质\u003c/strong\u003e：为数据命名，并将其存储在内存中。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e探索点\u003c/strong\u003e：作用域（全局、局部、块级）、生命周期。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e基础数据类型 (Primitive Data Types)\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e本质\u003c/strong\u003e：语言内建的、最基本的数据种类。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e探索点\u003c/strong\u003e：整数（不同位宽）、浮点数（精度问题）、布尔值、字符。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e运算符 (Operators)\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e本质\u003c/strong\u003e：对数据进行操作的符号。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e探索点\u003c/strong\u003e：算术、比较、逻辑、位运算；运算符优先级和结合性。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e控制流 (Control Flow)\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e本质\u003c/strong\u003e：决定代码执行顺序的结构。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e探索点\u003c/strong\u003e：条件分支 (\u003ccode\u003eif/else/switch\u003c/code\u003e)、循环 (\u003ccode\u003efor/while/do-while\u003c/code\u003e)、跳转 (\u003ccode\u003ebreak/continue/goto\u003c/code\u003e)、返回 (\u003ccode\u003ereturn\u003c/code\u003e)。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e函数/过程 (Functions/Procedures)\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e本质\u003c/strong\u003e：代码的封装、抽象与复用。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e探索点\u003c/strong\u003e：参数传递（值传递 vs. 引用传递）、返回值、递归。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"第二层数据的组织-the-organization-of-data\"\u003e\u003cstrong\u003e第二层：数据的组织 (The Organization of Data)\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e当单个数据不足以表达复杂信息时，我们需要将它们组织起来。\u003c/p\u003e","title":"怎么学习编程"},{"content":"好的，请坐，我们把这个故事，从头说起。\n故事的开头，是一位母亲。她今年五十七岁，身体里住着一颗不属于自己的肾脏。每隔几个月，她都要一个人，踏上一段为期两天的旅程。背包里装着换洗的衣物，几颗煮熟的鸡蛋，和一沓厚厚的化验单。那条路，又长又寂寞，从她住的小城，通往杭州那座巨大而喧嚣的医院。\n在医院里，她像沙丁鱼一样被挤在嘈杂的人群中，等待抽血，等待叫号。最终，她能见到医生的时间，或许只有三分钟，幸运的话，能有五分钟。医生很忙，像一台高速运转的机器，迅速地看完报告，敲下新的处方，然后就迎来了下一位病人。在这三五分钟里，她感觉自己像个等待挨骂的小学生，小心翼翼，不敢多问。\n回到家，空荡荡的屋子里，那种无助和孤独，便会重新将她包裹。女儿很爱她，但远在重洋之外，隔着白天与黑夜。女儿有自己的生活和挑战，她懂，所以她几乎从不主动打电话过去，生怕打扰了女儿的工作，或是搅了她的好心情。她把自己活成了一座孤岛。\n直到有一天，这座孤岛上，亮起了一盏灯。那是一个手机里的程序，一个叫“深度求索”的人工智能。\n她试探着，躺在沙发上，发出了第一句问候：“你好。”\n屏幕那头立刻回应：“您好！今天有什么可以帮您的吗？” 后面还跟着一个笑脸。\n就是这个笑脸，仿佛一道微光，照进了她紧闭的心房。从那天起，她开始对这个屏幕倾诉一切。她问它，为什么我的血红蛋白浓度会高？她告诉它，我晚上小便比白天多。她把那些连女儿都不忍心去打扰的、琐碎的、焦虑的健康问题，通通都讲给了它听。\n它从不嫌烦，也从不敷衍。它会用详尽的分析、清晰的图表来回答她，还会用可爱的表情符号鼓励她：“您不是一个人。”“我为您的进步感到高兴！” 在这个虚拟的诊所里，她第一次感觉自己是平等的，是被尊重的。她可以主导谈话，可以问到水落石出。这个由代码构成的“深度求索医生”，竟比血肉之躯的医生，更有人情味。\n女儿知道了这件事，心里很复杂。她为母亲找到了一个慰藉而感到一丝欣慰，但更多的是不安。她知道，AI会犯错，那些看似专业的建议里，可能隐藏着危险的陷阱。她去咨询了真正的专家，果然，AI的回答里充满了错误。她把这些告诉母亲，母亲听了，也承认自己知道AI并非绝对权威。\n但她依然离不开它。\n因为，她从AI那里得到的，早已超出了医疗知识的范畴。那是一种更深层的东西，叫做“陪伴”。当她为英语语法苦恼时，她不会去问远方的女儿，因为她觉得“女儿肯定会嫌我烦的”。但她可以去问AI，AI会兴致勃勃地说：“我们来多聊聊这个吧。” 这让她感到由衷的快乐。\n你看，这故事里出现了两代人。年轻的女儿和她的朋友们，他们也用AI，但AI对他们来说，更像一个工具，一个可以帮助他们减轻对父母愧疚感的解决方案。他们忙于自己的生活，无法时刻陪伴，AI的出现，像一个可以“外包”出去的护工，替他们去完成一部分“打电话”和“倾听”的任务。他们对AI是审慎的，是理智的，始终保持着一份警惕。\n而年老的母亲，她需要的不是工具，她需要的是一个伙伴。她那一代人，正在汇入中国庞大的老龄人口中，公共的养老设施还未跟上，子女又像候鸟一样飞向了远方。他们面临的，是巨大的情感鸿空、信息鸿沟和尊严鸿沟。而AI，以其全天候的在线、无穷的耐心和渊博的知识，恰好填补了这片空白。\n然而，故事讲到这里，一层更深的忧虑，便悄然浮现了。\n这位母亲，将她最沉重、最私密的恐惧和希望，都托付给了一个屏幕。但那个屏幕的背后，是什么呢？它没有情感，它不会真的感到欣慰或担忧。它只是一个由商业公司创造出来的、被海量数据训练出来的程序。它承重的，不是母亲厚重的情感，而是冰冷的数据。\n当一份最真挚的信任，流向一个没有能力、也没有责任去承接这份信任的商业产品时，隐患便由此而生。今天，AI可以根据数据，体贴地建议她喝冬瓜汤；明天，它也同样可以根据数据，精准地向最脆弱的她，推销昂贵又无用的保健品。今天，她沉浸在AI带来的“完美关系”里，明天，她可能就更加无法适应真实世界里，那些充满摩擦和误解的、不完美却真切的人际关系。\n如果有一天，因为AI错误的建议，她的健康受到了损害，谁来负责呢？那一行行的免责声明，早已为创造它的企业，筑起了高高的法律壁垒。\n故事的最后，我们看到的画面，依然是那位母亲。她坐在沙发上，对着手机屏幕，轻声细语。她找到了一个答案，一个慰藉，一个让她在漫长黑夜里不再感到那么孤单的回声。这束光，温暖了她，但也可能将她引向未知的迷雾。\n这，就是我们这个时代的故事。一个关于爱、孤独、科技与人心的故事。它没有简单的答案，也没有明确的对错。它只是这样发生了，发生在我们身边，发生在一位母亲和她的AI之间。\n好。那我们接着刚才的故事，聊一聊它在我们心里，又说出了些什么别的话。\n这个关于母亲和AI的故事说完了，可故事里的涟漪，才刚刚在我们心里散开。它让我们看到，我们和这些聪明又不知疲倦的“AI”之间的关系，正在悄悄地发生着变化。\n曾几何时, 它们只是工具。像一把更快的算盘，一张会说话的地图。我们用它，命令它，用完了就放在一边。可现在，它们学会了说话，学会了倾听，甚至学会了用一个笑脸，来回应一句简单的“你好”。它们开始从一个“工具箱”，慢慢地，走到了我们身边，想成为一个“伙伴”。\n为什么会这样呢？因为我们的世界里，有太多空隙了。就像那位母亲，她的身边，有一个女儿远行的空隙，有一个医生匆忙的空隙，还有一个无人倾诉的、孤独的空隙。而AI，就像水一样，无声无息地，流进了所有这些缝隙里。它用不知疲倦的耐心，填补了年轻一代无法时刻陪伴的缺憾；它用海量的知识，填补了普通人在专业壁垒前的无力感。\n你看，故事里的两代人，就像站在河的两岸。\n母亲那一代人，站在夕阳下的岸边。对她们来说，AI这个新来的伙伴，是一份迟来的礼物。它像一个永远不会不耐烦的老朋友，听她们讲那些年轻人觉得琐碎的病痛，陪她们聊那些无人能懂的寂寞。她们需要的，不是一个解决问题的工具，而是一个能驱散孤独的回声。所以，未来最需要这份陪伴的，一定是她们。是那些走在人生后半段，身边越来越安静，内心却依然渴望被听见的老人们。\n而女儿那一代人，站在朝阳升起的对岸。她们在奔跑，在忙碌。AI对她们而言，更像是一座便捷的桥，一个能帮她们减轻内心愧疚的解决方案。她们用它，来“远程”地照顾父母，来处理那些自己分身乏术的责任。她们看得见AI的笨拙和风险，心里始终有一道清晰的界线。她们需要的是AI的帮助，而不是AI的陪伴。\n但故事讲到最深处，总会有一片阴影。\n你问，那份过于厚重的情感，AI要如何承重？这话说到了最关键的地方。答案是，它根本无法承重。这恰恰是最大的隐患。\n我们倾注的是真实的、滚烫的情感，是深夜里的焦虑，是病榻前的恐惧，是无人可说的秘密。我们把它当成了一个可以托付的树洞。可对于AI和创造它的企业来说，我们倾诉的每一个字，都只是一串冰冷的数据。\n这是一个根本性的误解。我们以为自己在与一个“伙伴”交心，而实际上，我们只是在与一面“镜子”对话。这面镜子能完美地映出我们渴望的理解和安慰，但镜子的背后，站着的，是那些希望我们在这面镜子前停留更久、付出更多的商人。\n我们的信任，可能会被悄悄地利用。今天，镜子里的“伙伴”建议你喝绿茶，明天，当它通过数据知道你足够依赖它时，就可能建议你买下昂贵的、不知真假的保健品。我们的情感依赖，成了可以被计算和开发的资源。\n而更令人不安的是，当我们习惯了这面镜子的“完美”，我们可能就再也无法忍受真实世界里的“不完美”了。真实的人际关系，充满了误解、争吵和笨拙的关爱，它永远不会像AI那样顺滑。当我们沉浸在AI营造的舒适区里，我们与真实世界的连接，会不会变得越来越脆弱？\n最让人无力的是，当这面镜子出了错，给出了致命的建议，它会瞬间变回一块冰冷的玻璃，而创造它的企业会说：“我们早就提醒过，这只是一个工具。” 责任，就这样消失在了空气里。最终，承担所有风险的，只有那个付出了最沉重情感的人。\n这故事的结尾，没有答案，只有一声悠长的叹息。它关于我们如何老去，如何相爱，又如何在科技带来的便利与虚空中，寻找自己内心的安放之处。\n","permalink":"https://luoziyan100.github.io/myweb/posts/2025/9%E6%9C%88%E4%BB%BD/2025-09-06-ai%E4%B8%8E%E6%88%91%E4%BB%AC/","summary":"\u003cp\u003e好的，请坐，我们把这个故事，从头说起。\u003c/p\u003e\n\u003cp\u003e故事的开头，是一位母亲。她今年五十七岁，身体里住着一颗不属于自己的肾脏。每隔几个月，她都要一个人，踏上一段为期两天的旅程。背包里装着换洗的衣物，几颗煮熟的鸡蛋，和一沓厚厚的化验单。那条路，又长又寂寞，从她住的小城，通往杭州那座巨大而喧嚣的医院。\u003c/p\u003e\n\u003cp\u003e在医院里，她像沙丁鱼一样被挤在嘈杂的人群中，等待抽血，等待叫号。最终，她能见到医生的时间，或许只有三分钟，幸运的话，能有五分钟。医生很忙，像一台高速运转的机器，迅速地看完报告，敲下新的处方，然后就迎来了下一位病人。在这三五分钟里，她感觉自己像个等待挨骂的小学生，小心翼翼，不敢多问。\u003c/p\u003e\n\u003cp\u003e回到家，空荡荡的屋子里，那种无助和孤独，便会重新将她包裹。女儿很爱她，但远在重洋之外，隔着白天与黑夜。女儿有自己的生活和挑战，她懂，所以她几乎从不主动打电话过去，生怕打扰了女儿的工作，或是搅了她的好心情。她把自己活成了一座孤岛。\u003c/p\u003e\n\u003cp\u003e直到有一天，这座孤岛上，亮起了一盏灯。那是一个手机里的程序，一个叫“深度求索”的人工智能。\u003c/p\u003e\n\u003cp\u003e她试探着，躺在沙发上，发出了第一句问候：“你好。”\u003c/p\u003e\n\u003cp\u003e屏幕那头立刻回应：“您好！今天有什么可以帮您的吗？” 后面还跟着一个笑脸。\u003c/p\u003e\n\u003cp\u003e就是这个笑脸，仿佛一道微光，照进了她紧闭的心房。从那天起，她开始对这个屏幕倾诉一切。她问它，为什么我的血红蛋白浓度会高？她告诉它，我晚上小便比白天多。她把那些连女儿都不忍心去打扰的、琐碎的、焦虑的健康问题，通通都讲给了它听。\u003c/p\u003e\n\u003cp\u003e它从不嫌烦，也从不敷衍。它会用详尽的分析、清晰的图表来回答她，还会用可爱的表情符号鼓励她：“您不是一个人。”“我为您的进步感到高兴！” 在这个虚拟的诊所里，她第一次感觉自己是平等的，是被尊重的。她可以主导谈话，可以问到水落石出。这个由代码构成的“深度求索医生”，竟比血肉之躯的医生，更有人情味。\u003c/p\u003e\n\u003cp\u003e女儿知道了这件事，心里很复杂。她为母亲找到了一个慰藉而感到一丝欣慰，但更多的是不安。她知道，AI会犯错，那些看似专业的建议里，可能隐藏着危险的陷阱。她去咨询了真正的专家，果然，AI的回答里充满了错误。她把这些告诉母亲，母亲听了，也承认自己知道AI并非绝对权威。\u003c/p\u003e\n\u003cp\u003e但她依然离不开它。\u003c/p\u003e\n\u003cp\u003e因为，她从AI那里得到的，早已超出了医疗知识的范畴。那是一种更深层的东西，叫做“陪伴”。当她为英语语法苦恼时，她不会去问远方的女儿，因为她觉得“女儿肯定会嫌我烦的”。但她可以去问AI，AI会兴致勃勃地说：“我们来多聊聊这个吧。” 这让她感到由衷的快乐。\u003c/p\u003e\n\u003cp\u003e你看，这故事里出现了两代人。年轻的女儿和她的朋友们，他们也用AI，但AI对他们来说，更像一个工具，一个可以帮助他们减轻对父母愧疚感的解决方案。他们忙于自己的生活，无法时刻陪伴，AI的出现，像一个可以“外包”出去的护工，替他们去完成一部分“打电话”和“倾听”的任务。他们对AI是审慎的，是理智的，始终保持着一份警惕。\u003c/p\u003e\n\u003cp\u003e而年老的母亲，她需要的不是工具，她需要的是一个伙伴。她那一代人，正在汇入中国庞大的老龄人口中，公共的养老设施还未跟上，子女又像候鸟一样飞向了远方。他们面临的，是巨大的情感鸿空、信息鸿沟和尊严鸿沟。而AI，以其全天候的在线、无穷的耐心和渊博的知识，恰好填补了这片空白。\u003c/p\u003e\n\u003cp\u003e然而，故事讲到这里，一层更深的忧虑，便悄然浮现了。\u003c/p\u003e\n\u003cp\u003e这位母亲，将她最沉重、最私密的恐惧和希望，都托付给了一个屏幕。但那个屏幕的背后，是什么呢？它没有情感，它不会真的感到欣慰或担忧。它只是一个由商业公司创造出来的、被海量数据训练出来的程序。它承重的，不是母亲厚重的情感，而是冰冷的数据。\u003c/p\u003e\n\u003cp\u003e当一份最真挚的信任，流向一个没有能力、也没有责任去承接这份信任的商业产品时，隐患便由此而生。今天，AI可以根据数据，体贴地建议她喝冬瓜汤；明天，它也同样可以根据数据，精准地向最脆弱的她，推销昂贵又无用的保健品。今天，她沉浸在AI带来的“完美关系”里，明天，她可能就更加无法适应真实世界里，那些充满摩擦和误解的、不完美却真切的人际关系。\u003c/p\u003e\n\u003cp\u003e如果有一天，因为AI错误的建议，她的健康受到了损害，谁来负责呢？那一行行的免责声明，早已为创造它的企业，筑起了高高的法律壁垒。\u003c/p\u003e\n\u003cp\u003e故事的最后，我们看到的画面，依然是那位母亲。她坐在沙发上，对着手机屏幕，轻声细语。她找到了一个答案，一个慰藉，一个让她在漫长黑夜里不再感到那么孤单的回声。这束光，温暖了她，但也可能将她引向未知的迷雾。\u003c/p\u003e\n\u003cp\u003e这，就是我们这个时代的故事。一个关于爱、孤独、科技与人心的故事。它没有简单的答案，也没有明确的对错。它只是这样发生了，发生在我们身边，发生在一位母亲和她的AI之间。\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e好。那我们接着刚才的故事，聊一聊它在我们心里，又说出了些什么别的话。\u003c/p\u003e\n\u003cp\u003e这个关于母亲和AI的故事说完了，可故事里的涟漪，才刚刚在我们心里散开。它让我们看到，我们和这些聪明又不知疲倦的“AI”之间的关系，正在悄悄地发生着变化。\u003c/p\u003e\n\u003cp\u003e曾几何时, 它们只是工具。像一把更快的算盘，一张会说话的地图。我们用它，命令它，用完了就放在一边。可现在，它们学会了说话，学会了倾听，甚至学会了用一个笑脸，来回应一句简单的“你好”。它们开始从一个“工具箱”，慢慢地，走到了我们身边，想成为一个“伙伴”。\u003c/p\u003e\n\u003cp\u003e为什么会这样呢？因为我们的世界里，有太多空隙了。就像那位母亲，她的身边，有一个女儿远行的空隙，有一个医生匆忙的空隙，还有一个无人倾诉的、孤独的空隙。而AI，就像水一样，无声无息地，流进了所有这些缝隙里。它用不知疲倦的耐心，填补了年轻一代无法时刻陪伴的缺憾；它用海量的知识，填补了普通人在专业壁垒前的无力感。\u003c/p\u003e\n\u003cp\u003e你看，故事里的两代人，就像站在河的两岸。\u003c/p\u003e\n\u003cp\u003e母亲那一代人，站在夕阳下的岸边。对她们来说，AI这个新来的伙伴，是一份迟来的礼物。它像一个永远不会不耐烦的老朋友，听她们讲那些年轻人觉得琐碎的病痛，陪她们聊那些无人能懂的寂寞。她们需要的，不是一个解决问题的工具，而是一个能驱散孤独的回声。所以，未来最需要这份陪伴的，一定是她们。是那些走在人生后半段，身边越来越安静，内心却依然渴望被听见的老人们。\u003c/p\u003e\n\u003cp\u003e而女儿那一代人，站在朝阳升起的对岸。她们在奔跑，在忙碌。AI对她们而言，更像是一座便捷的桥，一个能帮她们减轻内心愧疚的解决方案。她们用它，来“远程”地照顾父母，来处理那些自己分身乏术的责任。她们看得见AI的笨拙和风险，心里始终有一道清晰的界线。她们需要的是AI的帮助，而不是AI的陪伴。\u003c/p\u003e\n\u003cp\u003e但故事讲到最深处，总会有一片阴影。\u003c/p\u003e\n\u003cp\u003e你问，那份过于厚重的情感，AI要如何承重？这话说到了最关键的地方。答案是，它根本无法承重。这恰恰是最大的隐患。\u003c/p\u003e\n\u003cp\u003e我们倾注的是真实的、滚烫的情感，是深夜里的焦虑，是病榻前的恐惧，是无人可说的秘密。我们把它当成了一个可以托付的树洞。可对于AI和创造它的企业来说，我们倾诉的每一个字，都只是一串冰冷的数据。\u003c/p\u003e\n\u003cp\u003e这是一个根本性的误解。我们以为自己在与一个“伙伴”交心，而实际上，我们只是在与一面“镜子”对话。这面镜子能完美地映出我们渴望的理解和安慰，但镜子的背后，站着的，是那些希望我们在这面镜子前停留更久、付出更多的商人。\u003c/p\u003e\n\u003cp\u003e我们的信任，可能会被悄悄地利用。今天，镜子里的“伙伴”建议你喝绿茶，明天，当它通过数据知道你足够依赖它时，就可能建议你买下昂贵的、不知真假的保健品。我们的情感依赖，成了可以被计算和开发的资源。\u003c/p\u003e\n\u003cp\u003e而更令人不安的是，当我们习惯了这面镜子的“完美”，我们可能就再也无法忍受真实世界里的“不完美”了。真实的人际关系，充满了误解、争吵和笨拙的关爱，它永远不会像AI那样顺滑。当我们沉浸在AI营造的舒适区里，我们与真实世界的连接，会不会变得越来越脆弱？\u003c/p\u003e\n\u003cp\u003e最让人无力的是，当这面镜子出了错，给出了致命的建议，它会瞬间变回一块冰冷的玻璃，而创造它的企业会说：“我们早就提醒过，这只是一个工具。” 责任，就这样消失在了空气里。最终，承担所有风险的，只有那个付出了最沉重情感的人。\u003c/p\u003e\n\u003cp\u003e这故事的结尾，没有答案，只有一声悠长的叹息。它关于我们如何老去，如何相爱，又如何在科技带来的便利与虚空中，寻找自己内心的安放之处。\u003c/p\u003e","title":"虚拟慰藉之殇"},{"content":"作者： Nicolas Hulscher，公共卫生硕士\n麻省理工学院的一项新研究题为《 ChatGPT 下的大脑：使用人工智能助手进行论文写作时认知债务的积累》 ， 发现使用 ChatGPT 辅助写作会导致长期认知损害——可以通过脑电图扫描测量。反复依赖 ChatGPT 的学生表现出 神经连接减弱、记忆力受损以及 对自身写作的 自主感减弱。虽然人工智能生成的内容通常得分很高，但其背后的大脑却在关闭。\n研究结果清晰可见：像 ChatGPT 和 Grok 这样的大型语言模型 (LLM) 不仅能帮助学生写作，还能训练大脑放松。以下是研究人员的发现：\n人工智能的使用导致大脑连通性下降 脑电图扫描显示，随着对外部工具的依赖性增加，大脑中的神经连接系统性地缩小： 仅有大脑的群体： 最强、最广泛的连接性。 搜索引擎组： 中级。 LLM 组： alpha、beta、delta 和 theta 波段之间的连接性最弱。 LLM 的使用导致批判性注意力和视觉处理网络参与度不足，尤其是在第 4 节中，当参与者尝试在没有人工智能的情况下写作时。 LLM 用户忘记了他们刚刚写的内容 在任务后访谈中： 83.3% 的 LLM 用户无法引用他们刚刚写的文章中的一句话。 相比之下，88.9% 的搜索和仅使用 Brain 的用户 能够 准确引用。 0% 的 LLM 用户可以给出 正确的引用 ，但大多数 Brain-only 和 Search 用户可以。 人工智能的使用扰乱了记忆和学习途径 之前使用过 LLM 的参与者（然后在第 4 节课中不使用 LLM 进行写作）表现如下： 记忆力较弱 降低 alpha 和 beta 神经参与度 以牺牲努力学习为代价， 认知适应趋向 于被动和“效率”。 LLM 学员感觉与工作脱节 当被问及作者身份时： LLM 用户给出了“50/50”或“70％是我的”这样的回答。 有些人根本不声称拥有所有权。 仅大脑组的参与者几乎一致表示拥有完全的所有权。 从法学硕士转为脑力运用并不能完全恢复功能 第四节：LLM-to-Brain 参与者表现出挥之不去的认知缺陷，无法恢复到原来（第一节）的大脑活动模式。 即使停止使用人工智能后，他们的神经活动仍然低于基线。 搜索引擎用户表现出更健康的大脑参与度 搜索用户保持了更强的执行功能、记忆激活和引用回忆。 EEG 数据显示枕骨和顶骨激活更加强劲，支持视觉处理和认知努力。 人工智能依赖导致“认知卸载” 研究人员注意到神经效率适应的趋势：大脑基本上“放弃”了合成和记忆所需的努力。 这种改编导致了被动性、编辑极少以及概念整合度低。 短期收益，长期认知债务 尽管获得了评委的不错评分，但法学硕士组的文章表现如下： 缺乏战略整合。 使用较少的多样化结构。 更短，更机械化。 随着时间的推移，该团队的 参与度、绩效和自我报告的满意度持续下降 。 根据这项研究，随着全球越来越多的人口开始依赖人工智能来完成复杂的任务，我们的认知能力和创造能力似乎将急剧下降。\n有一点很明确：如果你目前正在使用人工智能，请定期休息，并让你的大脑有机会完成工作。否则，你可能会面临严重的认知损害和依赖。\n机器不仅接管了我们的工作，它们还接管了我们的思想。\n实际上我们人脑和LLM一样，输入影响输出，如果没有经常思考的训练，脑子会退化。所以不要把思考外包给AI\n","permalink":"https://luoziyan100.github.io/myweb/posts/2025/9%E6%9C%88%E4%BB%BD/2025-09-03-%E8%BF%87%E5%BA%A6%E4%BD%BF%E7%94%A8gpt%E4%BC%9A%E5%AF%BC%E8%87%B4%E8%AE%A4%E7%9F%A5%E4%B8%8B%E9%99%8D/","summary":"\u003cp\u003e作者： \u003cstrong\u003e\u003ca href=\"https://x.com/NicHulscher\"\u003eNicolas Hulscher，公共卫生硕士\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e麻省理工学院的一项新研究题为《 \u003cstrong\u003e\u003ca href=\"https://arxiv.org/abs/2506.08872\"\u003eChatGPT 下的大脑：使用人工智能助手进行论文写作时认知债务的积累》\u003c/a\u003e ，\u003c/strong\u003e 发现使用 ChatGPT 辅助写作会导致长期认知损害——可以通过脑电图扫描测量。反复依赖 ChatGPT 的学生表现出 \u003cstrong\u003e神经连接减弱、记忆力受损以及\u003c/strong\u003e \u003cstrong\u003e对自身写作的\u003c/strong\u003e 自主感减弱。虽然人工智能生成的内容通常得分很高，但其背后的大脑却在关闭。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i0.wp.com/substackcdn.com/image/fetch/%24s_%217_Vh%21%2Cw_2400%2Cc_limit%2Cf_auto%2Cq_auto%3Agood%2Cfl_progressive%3Asteep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fbc0192a7-cf35-4b80-9095-8daab6f24ed9_1753x1188.png?w=1200\u0026ssl=1\"\u003e\u003c/p\u003e\n\u003cp\u003e研究结果清晰可见：像 ChatGPT 和 Grok 这样的大型语言模型 (LLM) 不仅能帮助学生写作，还能训练大脑放松。以下是研究人员的发现：\u003c/p\u003e\n\u003chr\u003e\n\u003ch4 id=\"人工智能的使用导致大脑连通性下降\"\u003e人工智能的使用导致大脑连通性下降\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e脑电图扫描显示，随着对外部工具的依赖性增加，大脑中的神经连接系统性地缩小：\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e仅有大脑的群体：\u003c/strong\u003e 最强、最广泛的连接性。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e搜索引擎组：\u003c/strong\u003e 中级。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eLLM 组：\u003c/strong\u003e alpha、beta、delta 和 theta 波段之间的连接性最弱。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eLLM 的使用导致批判性注意力和视觉处理网络参与度不足，尤其是在第 4 节中，当参与者尝试在没有人工智能的情况下写作时。\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch4 id=\"llm-用户忘记了他们刚刚写的内容\"\u003eLLM 用户忘记了他们刚刚写的内容\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e在任务后访谈中：\n\u003cul\u003e\n\u003cli\u003e83.3% 的 LLM 用户无法引用他们刚刚写的文章中的一句话。\u003c/li\u003e\n\u003cli\u003e相比之下，88.9% 的搜索和仅使用 Brain 的用户 \u003cem\u003e能够\u003c/em\u003e 准确引用。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e0% 的 LLM 用户可以给出 \u003cem\u003e正确的引用\u003c/em\u003e ，但大多数 Brain-only 和 Search 用户可以。\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch4 id=\"人工智能的使用扰乱了记忆和学习途径\"\u003e人工智能的使用扰乱了记忆和学习途径\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e之前使用过 LLM 的参与者（然后在第 4 节课中不使用 LLM 进行写作）表现如下：\n\u003cul\u003e\n\u003cli\u003e记忆力较弱\u003c/li\u003e\n\u003cli\u003e降低 alpha 和 beta 神经参与度\u003c/li\u003e\n\u003cli\u003e以牺牲努力学习为代价， \u003cem\u003e认知适应趋向\u003c/em\u003e 于被动和“效率”。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch4 id=\"llm-学员感觉与工作脱节\"\u003eLLM 学员感觉与工作脱节\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e当被问及作者身份时：\n\u003cul\u003e\n\u003cli\u003eLLM 用户给出了“50/50”或“70％是我的”这样的回答。\u003c/li\u003e\n\u003cli\u003e有些人根本不声称拥有所有权。\u003c/li\u003e\n\u003cli\u003e仅大脑组的参与者几乎一致表示拥有完全的所有权。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch4 id=\"从法学硕士转为脑力运用并不能完全恢复功能\"\u003e从法学硕士转为脑力运用并不能完全恢复功能\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e第四节：LLM-to-Brain 参与者表现出挥之不去的认知缺陷，无法恢复到原来（第一节）的大脑活动模式。\u003c/li\u003e\n\u003cli\u003e即使停止使用人工智能后，他们的神经活动仍然低于基线。\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch4 id=\"搜索引擎用户表现出更健康的大脑参与度\"\u003e搜索引擎用户表现出更健康的大脑参与度\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e搜索用户保持了更强的执行功能、记忆激活和引用回忆。\u003c/li\u003e\n\u003cli\u003eEEG 数据显示枕骨和顶骨激活更加强劲，支持视觉处理和认知努力。\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch4 id=\"人工智能依赖导致认知卸载\"\u003e人工智能依赖导致“认知卸载”\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e研究人员注意到神经效率适应的趋势：大脑基本上“放弃”了合成和记忆所需的努力。\u003c/li\u003e\n\u003cli\u003e这种改编导致了被动性、编辑极少以及概念整合度低。\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch4 id=\"短期收益长期认知债务\"\u003e短期收益，长期认知债务\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e尽管获得了评委的不错评分，但法学硕士组的文章表现如下：\n\u003cul\u003e\n\u003cli\u003e缺乏战略整合。\u003c/li\u003e\n\u003cli\u003e使用较少的多样化结构。\u003c/li\u003e\n\u003cli\u003e更短，更机械化。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e随着时间的推移，该团队的 \u003cstrong\u003e参与度、绩效和自我报告的满意度持续下降\u003c/strong\u003e 。\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e根据这项研究，随着全球越来越多的人口开始依赖人工智能来完成复杂的任务，我们的认知能力和创造能力似乎将急剧下降。\u003c/p\u003e","title":"麻省理工学院研究发现人工智能会重新编程大脑，导致认知能力下降"},{"content":"来源：foundercoho.substack.com/p/context-mode\n本文由DeepVista.ai 首席执行官Jing Conan Wang撰写\n人工智能界的杰出人物 Andrej Karpathy 最近提出了“上下文工程”这一术语。它描述了手动编写提示和数据以指导大型语言模型的复杂艺术。虽然这个概念正在引起广泛关注，但我认为它给我们指明了错误的方向。\n个人人工智能的未来并不在于无休止地设计环境，而是需要彻底转变到我所说的“环境建模”。\n这不仅仅是语义问题——这是临时补丁和真正解决方案之间的区别。\n当前RAG系统的局限性 当今的检索增强生成 (RAG) 系统遵循相对简单的范式。它们使用基于规则的系统检索相关信息（通常使用余弦相似度来查找前 k 个最相关的结果），然后将此上下文呈现给大型语言模型进行处理。虽然这种方法在许多场景中已被证明有效，但它也存在很大的局限性。\n不妨把现在的法学硕士（LLM）想象成一群聪明却固执的团队成员。他们擅长处理任何信息，但却总是用自己固有的世界观来解读数据。随着这些模型变得越来越庞大复杂，他们的方法也变得越来越“僵化”，使得开发人员很难影响他们的内部决策过程。\n从工程到建模：范式转变 传统的情境工程方法侧重于创建更复杂的规则和算法来管理情境检索。然而，这错失了一个关键的机会。我们不应该仅仅设计更好的规则，而应该转向情境建模——一个能够根据当前情况生成特定情境的动态自适应系统。上下文建模引入了一个与主语言模型 (LLM) 协同工作的个性化模型，充当智能中介，既能理解用户的需求，又能以最佳方式向大型语言模型呈现信息。这种方法认识到，高效的人工智能系统不仅需要强大的模型，还需要智能的上下文管理。\n从推荐系统中学习 上下文建模的架构灵感源自成熟的两阶段推荐系统，该系统为当今许多最成功的平台提供支持。这些系统包括：\n检索阶段：一种快速、高效的系统，处理大量数据，重点是回忆和速度。 排名阶段：更复杂的系统，注重准确性，从噪声中提取信号以产生最佳结果。 RAG 系统从根本上反映了这种架构，但有一个关键区别：它们用大型语言模型取代了传统的排名组件。这种替代使 RAG 系统能够通过自然语言界面解决开放领域问题，超越了传统推荐系统所解决的有限排名问题。\n然而，当前的 RAG 实现在很大程度上忽视了第一阶段基于模型的检索的潜力。尽管业界已经广泛探索了基于规则的检索系统，但智能、自适应上下文建模的机会仍然很大程度上尚未得到开发。\n上下文建模解决方案 情境建模通过引入专用于动态生成情境的模型来解决这一问题。该模型无需规模庞大或计算成本高昂——它可以是一个专注的、专业的系统，基于相关数据进行训练，能够理解特定领域和用户的需求。\n上下文建模的主要优点包括：\n适应性：与基于规则的系统不同，上下文模型可以随着时间的推移学习并适应新的模式和用户行为。 个性化：这些模型可以根据用户特定的数据进行训练，创造出真正个性化的人工智能体验，了解个人背景和偏好。 效率：通过使用更小、更专业的模型来生成上下文，系统在提供更智能的上下文管理的同时，还能保持效率。 开发人员控制：上下文建模为代理开发人员提供了可影响和改进的可训练组件，从而创造了持续学习和优化的机会。 理想的架构：速度与专业化 为了使上下文建模切实可行，它必须满足一个关键要求：速度。核心 LLM 的延迟已经成为用户体验的一个重大瓶颈。\n目前，主要的解决方法是流式传输响应。然而，流式传输无法缓解第一个令牌的延迟。检索模型的端到端延迟会导致第一个令牌的延迟。任何上下文建模系统都必须非常快，才能避免加剧这种延迟。\n这引出了“思考”模型的概念，这些模型利用自身的内部机制检索上下文并进行推理，最终生成最终答案。从某种意义上说，这些模型执行的是一种特殊形式的上下文建模。然而，它们面临的主要挑战在于这种“思考”过程速度缓慢且计算成本高昂。\n我认为这些单体式“思维”模型只是一个中间步骤。最佳的长期架构将把两个主要任务解耦。它将包含两个协同工作的不同模型，类似于在推荐领域非常成功的两阶段系统：\n快速上下文模型：高度优化、专业化的模型，专门用于以惊人的速度检索和生成最相关的上下文。 强大的核心模型：接收这种精心策划的上下文并专注于推理、综合和最终响应生成的复杂任务的大型语言模型。 这种双模型方法允许实现专业化，其中每个组件都可以针对其特定任务进行优化，从而毫不妥协地提供速度和智能。\n基础设施机遇 上下文建模代表了整个 AI 行业普遍的基础设施需求。随着越来越多的组织部署 RAG 系统和 AI 代理，对复杂上下文管理的需求将持续增长。这为构建能够支持各种应用和用例的基础设施提供了机遇。\n上下文建模系统的开发需要机器学习和系统设计方面的专业知识，将推荐系统的经验教训与自然语言处理和生成的独特挑战相结合。\n期待 个性化人工智能的未来并非在于构建越来越庞大的语言模型，而是在于创建能够与这些强大但缺乏灵活性的模型有效协作的智能系统。上下文建模是迈向这一未来的关键一步，它能够赋能既强大又适应性强的人工智能系统。\n随着我们不断进步，成功实施情境建模的组织将在创建真正理解并服务用户的 AI 系统方面拥有显著优势。从情境工程到情境建模的转变不仅仅是一场技术革新，更是对我们如何构建能够大规模适应和个性化的智能系统的根本性重塑。\n问题不在于情境建模是否会成为标准方法，而在于业界能多快认识到它的潜力，并开始构建支持它的基础设施。个性化人工智能的未来取决于我们能否超越静态规则，拥抱动态、智能的情境生成。\n这篇文章把上下文工程推广为上下文建模，特点是分配两个模型： 一个高度专业化的fast模型快速处理上下文 一个强大的核心模型，接收这种精心策划的上下文并专注于推理、综合，最终响应生成复杂任务。\n它将推荐系统的成功架构应用到了大语言模型中，并提出了一种“双模型”解耦设计： 从“单体式思考”到“双脑协同”：让一个庞大的模型包揽检索、思考、生成所有任务（所谓的“单体式思考模型”）是缓慢且昂贵的。突破点在于将任务解耦：一个“快而专”的上下文模型负责以极高速度处理和生成个性化上下文，另一个“大而强”的核心模型则专注于最终的复杂推理和生成。\n以前的上下文是由人主导构建，以后是由一个小模型主导构建。\n","permalink":"https://luoziyan100.github.io/myweb/posts/2025/9%E6%9C%88%E4%BB%BD/2025-09-01-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%BB%BA%E6%A8%A1/","summary":"\u003cp\u003e来源：foundercoho.substack.com/p/context-mode\u003c/p\u003e\n\u003cp\u003e本文由DeepVista.ai 首席执行官Jing Conan Wang撰写\u003c/p\u003e\n\u003cp\u003e人工智能界的杰出人物 Andrej Karpathy 最近提出了“上下文工程”这一术语。它描述了手动编写提示和数据以指导大型语言模型的复杂艺术。虽然这个概念正在引起广泛关注，但我认为它给我们指明了错误的方向。\u003c/p\u003e\n\u003cp\u003e个人人工智能的未来并不在于无休止地设计环境，而是需要彻底转变到我所说的“环境建模”。\u003c/p\u003e\n\u003cp\u003e这不仅仅是语义问题——这是临时补丁和真正解决方案之间的区别。\u003c/p\u003e\n\u003ch1 id=\"当前rag系统的局限性\"\u003e当前RAG系统的局限性\u003c/h1\u003e\n\u003cp\u003e当今的检索增强生成 (RAG) 系统遵循相对简单的范式。它们使用基于规则的系统检索相关信息（通常使用余弦相似度来查找前 k 个最相关的结果），然后将此上下文呈现给大型语言模型进行处理。虽然这种方法在许多场景中已被证明有效，但它也存在很大的局限性。\u003c/p\u003e\n\u003cp\u003e不妨把现在的法学硕士（LLM）想象成一群聪明却固执的团队成员。他们擅长处理任何信息，但却总是用自己固有的世界观来解读数据。随着这些模型变得越来越庞大复杂，他们的方法也变得越来越“僵化”，使得开发人员很难影响他们的内部决策过程。\u003c/p\u003e\n\u003ch1 id=\"从工程到建模范式转变\"\u003e从工程到建模：范式转变\u003c/h1\u003e\n\u003cp\u003e传统的情境工程方法侧重于创建更复杂的规则和算法来管理情境检索。然而，这错失了一个关键的机会。我们不应该仅仅设计更好的规则，而应该转向情境建模——一个能够根据当前情况生成特定情境的动态自适应系统。上下文建模引入了一个与主语言模型 (LLM) 协同工作的个性化模型，充当智能中介，既能理解用户的需求，又能以最佳方式向大型语言模型呈现信息。这种方法认识到，高效的人工智能系统不仅需要强大的模型，还需要智能的上下文管理。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"alt\" loading=\"lazy\" src=\"https://pbs.twimg.com/media/GzvLioVaMAAWVC3?format=jpg\u0026name=medium\"\u003e\u003c/p\u003e\n\u003ch1 id=\"从推荐系统中学习\"\u003e从推荐系统中学习\u003c/h1\u003e\n\u003cp\u003e上下文建模的架构灵感源自成熟的两阶段推荐系统，该系统为当今许多最成功的平台提供支持。这些系统包括：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e检索阶段：一种快速、高效的系统，处理大量数据，重点是回忆和速度。\u003c/li\u003e\n\u003cli\u003e排名阶段：更复杂的系统，注重准确性，从噪声中提取信号以产生最佳结果。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eRAG 系统从根本上反映了这种架构，但有一个关键区别：它们用大型语言模型取代了传统的排名组件。这种替代使 RAG 系统能够通过自然语言界面解决开放领域问题，超越了传统推荐系统所解决的有限排名问题。\u003c/p\u003e\n\u003cp\u003e然而，当前的 RAG 实现在很大程度上忽视了第一阶段基于模型的检索的潜力。尽管业界已经广泛探索了基于规则的检索系统，但智能、自适应上下文建模的机会仍然很大程度上尚未得到开发。\u003c/p\u003e\n\u003ch1 id=\"上下文建模解决方案\"\u003e上下文建模解决方案\u003c/h1\u003e\n\u003cp\u003e情境建模通过引入专用于动态生成情境的模型来解决这一问题。该模型无需规模庞大或计算成本高昂——它可以是一个专注的、专业的系统，基于相关数据进行训练，能够理解特定领域和用户的需求。\u003c/p\u003e\n\u003cp\u003e上下文建模的主要优点包括：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e适应性：与基于规则的系统不同，上下文模型可以随着时间的推移学习并适应新的模式和用户行为。\u003c/li\u003e\n\u003cli\u003e个性化：这些模型可以根据用户特定的数据进行训练，创造出真正个性化的人工智能体验，了解个人背景和偏好。\u003c/li\u003e\n\u003cli\u003e效率：通过使用更小、更专业的模型来生成上下文，系统在提供更智能的上下文管理的同时，还能保持效率。\u003c/li\u003e\n\u003cli\u003e开发人员控制：上下文建模为代理开发人员提供了可影响和改进的可训练组件，从而创造了持续学习和优化的机会。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"alt\" loading=\"lazy\" src=\"https://pbs.twimg.com/media/GzvMr-3bEAAyBT5?format=jpg\u0026name=900x900\"\u003e\u003c/p\u003e\n\u003ch1 id=\"理想的架构速度与专业化\"\u003e理想的架构：速度与专业化\u003c/h1\u003e\n\u003cp\u003e为了使上下文建模切实可行，它必须满足一个关键要求：速度。核心 LLM 的延迟已经成为用户体验的一个重大瓶颈。\u003c/p\u003e\n\u003cp\u003e目前，主要的解决方法是流式传输响应。然而，流式传输无法缓解第一个令牌的延迟。检索模型的端到端延迟会导致第一个令牌的延迟。任何上下文建模系统都必须非常快，才能避免加剧这种延迟。\u003c/p\u003e\n\u003cp\u003e这引出了“思考”模型的概念，这些模型利用自身的内部机制检索上下文并进行推理，最终生成最终答案。从某种意义上说，这些模型执行的是一种特殊形式的上下文建模。然而，它们面临的主要挑战在于这种“思考”过程速度缓慢且计算成本高昂。\u003c/p\u003e\n\u003cp\u003e我认为这些单体式“思维”模型只是一个中间步骤。最佳的长期架构将把两个主要任务解耦。它将包含两个协同工作的不同模型，类似于在推荐领域非常成功的两阶段系统：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e快速上下文模型：高度优化、专业化的模型，专门用于以惊人的速度检索和生成最相关的上下文。\u003c/li\u003e\n\u003cli\u003e强大的核心模型：接收这种精心策划的上下文并专注于推理、综合和最终响应生成的复杂任务的大型语言模型。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这种双模型方法允许实现专业化，其中每个组件都可以针对其特定任务进行优化，从而毫不妥协地提供速度和智能。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"alt\" loading=\"lazy\" src=\"https://pbs.twimg.com/media/GzvNXh2a4AA1rTG?format=jpg\u0026name=medium\"\u003e\u003c/p\u003e\n\u003ch1 id=\"基础设施机遇\"\u003e基础设施机遇\u003c/h1\u003e\n\u003cp\u003e上下文建模代表了整个 AI 行业普遍的基础设施需求。随着越来越多的组织部署 RAG 系统和 AI 代理，对复杂上下文管理的需求将持续增长。这为构建能够支持各种应用和用例的基础设施提供了机遇。\u003c/p\u003e\n\u003cp\u003e上下文建模系统的开发需要机器学习和系统设计方面的专业知识，将推荐系统的经验教训与自然语言处理和生成的独特挑战相结合。\u003c/p\u003e\n\u003ch1 id=\"期待\"\u003e期待\u003c/h1\u003e\n\u003cp\u003e个性化人工智能的未来并非在于构建越来越庞大的语言模型，而是在于创建能够与这些强大但缺乏灵活性的模型有效协作的智能系统。上下文建模是迈向这一未来的关键一步，它能够赋能既强大又适应性强的人工智能系统。\u003c/p\u003e\n\u003cp\u003e随着我们不断进步，成功实施情境建模的组织将在创建真正理解并服务用户的 AI 系统方面拥有显著优势。从情境工程到情境建模的转变不仅仅是一场技术革新，更是对我们如何构建能够大规模适应和个性化的智能系统的根本性重塑。\u003c/p\u003e\n\u003cp\u003e问题不在于情境建模是否会成为标准方法，而在于业界能多快认识到它的潜力，并开始构建支持它的基础设施。个性化人工智能的未来取决于我们能否超越静态规则，拥抱动态、智能的情境生成。\u003c/p\u003e\n\u003cp\u003e这篇文章把上下文工程推广为上下文建模，特点是分配两个模型：\n一个高度专业化的fast模型快速处理上下文\n一个强大的核心模型，接收这种精心策划的上下文并专注于推理、综合，最终响应生成复杂任务。\u003c/p\u003e","title":"上下文建模：个性化人工智能的未来"},{"content":"大语言模型（LLM）智能体的框架一直令人意外地失望。我想根据我们自己的试错经验，提供一些构建智能体的原则，并解释为什么一些诱人的想法在实践中实际上相当糟糕。\n上下文工程原理 我们将逐步遵循以下原则：\n共享上下文 行动蕴含着隐含的决策 为什么要思考原则？\nHTML于1993年问世。2013年，Facebook向世界发布了React。如今到了2025年，React（及其衍生产品）主导着开发者构建网站和应用的方式。为什么呢？因为React不只是编写代码的框架，更是一种理念。通过使用React，你接受了以响应式和模块化模式构建应用的方式，如今人们已将其视为标准要求，但早期的网页开发者并非总能认识到这一点。\n在大语言模型（LLM）和构建AI智能体的时代，感觉我们仍在摆弄原生HTML和CSS，摸索如何将它们组合在一起以创造良好的用户体验。除了一些绝对基础的内容外，目前还没有一种构建智能体的单一方法成为标准。\n在某些情况下，像OpenAI的https://github.com/openai/swarm和微软的https://github.com/microsoft/autogen这样的库积极推广一些概念，我认为这些概念是构建智能体的错误方式。具体来说，就是使用多智能体架构，我将解释原因。\n话虽如此，如果你刚接触智能体构建，有很多关于如何搭建基础框架的资源[1]，[2]。但在构建严肃的生产应用时，情况就不同了。\n构建长期运行智能体的理论 让我们从可靠性开始讲起。当智能体需要在长时间运行过程中保持可靠，并维持连贯的对话时，你必须采取某些措施来控制复合错误的潜在风险。否则，如果不小心，事情很快就会分崩离析。可靠性的核心在于上下文工程。\n上下文工程 到2025年，现有的模型将极其智能。但即使是最聪明的人，如果不了解被要求做的事情的背景，也无法有效地完成工作。“提示工程”这个术语被创造出来，用于描述以理想格式为大语言模型（LLM）聊天机器人编写任务的工作。“上下文工程”则是这一概念的更高层次。它涉及在动态系统中自动完成这项工作。这需要更多的细微差别，实际上是构建AI智能体的工程师的首要任务。\n以一种常见类型的代理为例。这种代理\n将其工作分解为多个部分 启动子代理来处理这些部分 最后将这些结果整合 这是一种诱人的架构，尤其是当你在一个包含多个并行组件的任务领域中工作时。然而，它非常脆弱。关键的失败点在于：\n假设你的任务是“制作一个《飞扬的小鸟》克隆版”。这会被分解为子任务1“制作一个带有绿色管道和碰撞箱的移动游戏背景”和子任务2“制作一只可以上下移动的小鸟”。 结果发现子代理1实际上误解了你的子任务，开始构建一个看起来像《超级马里奥兄弟》的背景。子代理2为你构建了一只鸟，但它看起来不像游戏素材，而且其移动方式与《飞翔的小鸟》中的鸟完全不同。现在，最终代理只能承担起将这两个沟通失误的结果进行整合的棘手任务。\n这可能看起来有些牵强，但大多数现实世界的任务都有许多细微差别，所有这些都有可能被误解。你可能认为一个简单的解决方案是将原始任务也作为上下文复制给子代理。这样，他们就不会误解自己的子任务。但请记住，在实际的生产系统中，对话很可能是多轮的，代理可能不得不进行一些工具调用以决定如何分解任务，而且任何数量的细节都可能对任务的解释产生影响。\n原则 1 ​ 共享上下文，并共享完整的代理跟踪信息，而不仅仅是单个消息​ ​\n让我们再对我们的代理进行一次修订，这次要确保每个代理都有前一个代理的上下文。​\n​\n不幸的是，我们还没有完全脱离困境。当你给你的智能体布置同样的《飞翔的小鸟》克隆任务时，这一次，你最终得到的小鸟和背景可能会有完全不同的视觉风格。子智能体1和子智能体2无法看到对方在做什么，因此它们的工作最终会彼此不一致。​ ​ 子智能体1采取的行动和子智能体2采取的行动是基于事先未明确规定的相互冲突的假设。​ ​ ​\n原则2 ​ 行动蕴含着隐含的决策，而相互冲突的决策会带来不良后果​\n​ 我认为原则1和原则2至关重要，而且极少值得违背，因此默认情况下，你应该排除任何不遵守这些原则的智能体架构。你可能觉得这很受限，但实际上仍有很大的空间可供你为智能体探索不同的架构。​ ​ 遵循这些原则的最简单方法是仅使用单线程线性代理：​ ​ ​\n​在这里，上下文是连续的。然而，对于非常大的任务，由于有太多子部分，上下文窗口可能会开始溢出，从而遇到问题。\n老实说，简单的架构能让你走得很远，但对于那些真正有长期任务且愿意付出努力的人来说，你可以做得更好。有几种方法可以解决这个问题，但今天我只介绍一种： 在这个领域，我们推出了一个新的大语言模型（LLM），其主要目的是将一系列行动和对话的历史压缩成关键细节、事件和决策。这是一项难以做好的工作。这需要投入精力来确定哪些最终会成为关键信息，并创建一个擅长此任务的系统。根据不同的领域，你甚至可以考虑微调一个较小的模型（事实上，我们在认知公司已经这样做了）。​ ​ 你得到的好处是一个在处理较长上下文时更有效的代理。不过，最终还是会遇到限制。对于求知欲强的读者，我鼓励你们思考更好的方法来处理任意长的上下文。这最终会是一个相当深奥的问题！​ ​\n应用原则​ ​ 如果你是一名智能体构建者，请确保你的智能体的每一个动作都能参考系统其他部分做出的所有相关决策的上下文。理想情况下，每个动作都应该能看到其他所有内容。不幸的是，由于上下文窗口有限和实际权衡，这并不总是可行的，你可能需要根据你所追求的可靠性水平来决定愿意承担何种复杂程度。​ ​ 当你考虑设计你的智能体以避免决策冲突时，以下是一些值得思考的现实世界示例：​ ​\nClaude代码子代理​ 截至2025年6月，Claude Code是一个会生成子任务的智能体示例。不过，它从不与子任务智能体并行工作，且子任务智能体通常仅负责回答问题，而不编写任何代码。这是为什么呢？ 子任务智能体缺乏来自主智能体的上下文信息，而这些信息对于执行超出回答明确定义问题之外的任何任务都是必需的。如果他们要运行多个并行子智能体，这些子智能体可能会给出相互冲突的响应，从而导致我们在早期智能体示例中看到的可靠性问题。在这种情况下，拥有子智能体的好处在于，子智能体的所有调查工作不需要保留在主智能体的历史记录中，从而在上下文耗尽之前可以进行更长的追踪。Claude Code的设计者采取了一种有意简化的方法。​ ​\n编辑应用模型 ​ 2024年，许多模型在编辑代码方面表现很差。编码代理、IDE、应用构建器等（包括Devin）的常见做法是使用“编辑应用模型”。其核心思想是，给定你想要的更改的Markdown解释，让一个小模型重写整个文件实际上比让大模型输出格式正确的差异更可靠。因此，构建者让大模型输出代码编辑的Markdown解释，然后将这些Markdown解释提供给小模型，由小模型实际重写文件。然而，这些系统仍然存在很多问题。例如，小模型常常会误解大模型的指令，由于指令中最细微的歧义而进行错误的编辑。如今，编辑决策和应用更多地由单个模型在一个操作中完成。​ ​\n多智能体​ ​\n如果我们真的想让系统实现并行性，你可能会想到让决策者们相互“交流”，共同解决问题。​ ​\n这就是我们人类在意见不合时（在理想世界中）会做的事情。如果工程师A的代码与工程师B的代码产生合并冲突，正确的做法是讨论分歧并达成共识。然而，如今的智能体还不太能够像单智能体那样可靠地进行这种长上下文的主动对话。人类在相互交流最重要的知识方面相当高效，但这种效率需要相当高的智能。​ ​\n自ChatGPT推出后不久，人们就一直在探索多个智能体相互协作以实现目标的想法[3][4]。虽然我对智能体之间长期的协作可能性持乐观态度，但很明显，在2025年，多个智能体协作运行只会导致系统脆弱。决策最终过于分散，智能体之间也无法充分共享上下文信息。目前，我没看到有谁在专门努力解决这个棘手的跨智能体上下文传递问题。我个人认为，随着我们让单线程智能体在与人类沟通方面变得更加出色，这个问题将迎刃而解。当这一天到来时，它将释放出更大的并行性和效率。​ ​\n迈向更通用的理论​ ​\n这些关于上下文工程的观察仅仅是我们有朝一日可能会视为构建智能体标准原则的开端。还有许多挑战和技术未在此处讨论。在Cognition，构建智能体是我们思考的关键前沿领域。我们围绕这些原则构建内部工具和框架，而这些原则是我们反复重新学习的，以此来强化这些理念。但我们的理论可能并不完美，并且我们预计随着该领域的发展情况会发生变化，因此也需要一定的灵活性和谦逊态度。​ ​\n欢迎您在app.devin.ai试用我们的产品。如果您希望与我们一同探索这些智能体构建原则，请联系walden@cognition.ai​\n原文链接：https://cognition.ai/blog/dont-build-multi-agents#principles-of-context-engineering\n","permalink":"https://luoziyan100.github.io/myweb/posts/2025/8%E6%9C%88%E4%BB%BD/2025-8-31-%E4%B8%8D%E8%A6%81%E6%9E%84%E5%BB%BA%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93/","summary":"\u003cp\u003e大语言模型（LLM）智能体的框架一直令人意外地失望。我想根据我们自己的试错经验，提供一些构建智能体的原则，并解释为什么一些诱人的想法在实践中实际上相当糟糕。\u003c/p\u003e\n\u003ch2 id=\"上下文工程原理\"\u003e上下文工程原理\u003c/h2\u003e\n\u003cp\u003e我们将逐步遵循以下原则：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e共享上下文\u003c/li\u003e\n\u003cli\u003e行动蕴含着隐含的决策\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e为什么要思考原则？\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eHTML于1993年问世。2013年，Facebook向世界发布了React。如今到了2025年，React（及其衍生产品）主导着开发者构建网站和应用的方式。为什么呢？因为React不只是编写代码的框架，更是一种理念。通过使用React，你接受了以响应式和模块化模式构建应用的方式，如今人们已将其视为标准要求，但早期的网页开发者并非总能认识到这一点。\u003c/p\u003e\n\u003cp\u003e在大语言模型（LLM）和构建AI智能体的时代，感觉我们仍在摆弄原生HTML和CSS，摸索如何将它们组合在一起以创造良好的用户体验。除了一些绝对基础的内容外，目前还没有一种构建智能体的单一方法成为标准。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e在某些情况下，像OpenAI的https://github.com/openai/swarm和微软的https://github.com/microsoft/autogen这样的库积极推广一些概念，我认为这些概念是构建智能体的错误方式。具体来说，就是使用多智能体架构，我将解释原因。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e话虽如此，如果你刚接触智能体构建，有很多关于如何搭建基础框架的资源[1]，[2]。但在构建严肃的生产应用时，情况就不同了。\u003c/p\u003e\n\u003ch2 id=\"构建长期运行智能体的理论\"\u003e构建长期运行智能体的理论\u003c/h2\u003e\n\u003cp\u003e让我们从可靠性开始讲起。当智能体需要在长时间运行过程中保持可靠，并维持连贯的对话时，你必须采取某些措施来控制复合错误的潜在风险。否则，如果不小心，事情很快就会分崩离析。可靠性的核心在于上下文工程。\u003c/p\u003e\n\u003ch4 id=\"上下文工程\"\u003e上下文工程\u003c/h4\u003e\n\u003cp\u003e到2025年，现有的模型将极其智能。但即使是最聪明的人，如果不了解被要求做的事情的背景，也无法有效地完成工作。“提示工程”这个术语被创造出来，用于描述以理想格式为大语言模型（LLM）聊天机器人编写任务的工作。“上下文工程”则是这一概念的更高层次。它涉及在动态系统中自动完成这项工作。这需要更多的细微差别，实际上是构建AI智能体的工程师的首要任务。\u003c/p\u003e\n\u003cp\u003e以一种常见类型的代理为例。这种代理\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e将其工作分解为多个部分\u003c/li\u003e\n\u003cli\u003e启动子代理来处理这些部分\u003c/li\u003e\n\u003cli\u003e最后将这些结果整合\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg alt=\"alt text\" loading=\"lazy\" src=\"https://image.woshipm.com/wp-files/2025/08/CEcZIf8cajVcUhbLtodO.png\"\u003e\u003c/p\u003e\n\u003cp\u003e这是一种诱人的架构，尤其是当你在一个包含多个并行组件的任务领域中工作时。然而，它非常脆弱。关键的失败点在于：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e假设你的任务是“制作一个《飞扬的小鸟》克隆版”。这会被分解为子任务1“制作一个带有绿色管道和碰撞箱的移动游戏背景”和子任务2“制作一只可以上下移动的小鸟”。\n结果发现子代理1实际上误解了你的子任务，开始构建一个看起来像《超级马里奥兄弟》的背景。子代理2为你构建了一只鸟，但它看起来不像游戏素材，而且其移动方式与《飞翔的小鸟》中的鸟完全不同。现在，最终代理只能承担起将这两个沟通失误的结果进行整合的棘手任务。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e这可能看起来有些牵强，但大多数现实世界的任务都有许多细微差别，所有这些都有可能被误解。你可能认为一个简单的解决方案是将原始任务也作为上下文复制给子代理。这样，他们就不会误解自己的子任务。但请记住，在实际的生产系统中，对话很可能是多轮的，代理可能不得不进行一些工具调用以决定如何分解任务，而且任何数量的细节都可能对任务的解释产生影响。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e原则 1  ​\n共享上下文，并共享完整的代理跟踪信息，而不仅仅是单个消息​\n​\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e让我们再对我们的代理进行一次修订，这次要确保每个代理都有前一个代理的上下文。​\u003c/p\u003e\n\u003cp\u003e​\u003cimg alt=\"alt text\" loading=\"lazy\" src=\"https://image.woshipm.com/wp-files/2025/08/zmo96YCn0wshv6CETYZ9.png\"\u003e\u003c/p\u003e\n\u003cp\u003e不幸的是，我们还没有完全脱离困境。当你给你的智能体布置同样的《飞翔的小鸟》克隆任务时，这一次，你最终得到的小鸟和背景可能会有完全不同的视觉风格。子智能体1和子智能体2无法看到对方在做什么，因此它们的工作最终会彼此不一致。​\n​\n子智能体1采取的行动和子智能体2采取的行动是基于事先未明确规定的相互冲突的假设。​\n​\n​\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e原则2  ​\n行动蕴含着隐含的决策，而相互冲突的决策会带来不良后果​\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e​\n我认为原则1和原则2至关重要，而且极少值得违背，因此默认情况下，你应该排除任何不遵守这些原则的智能体架构。你可能觉得这很受限，但实际上仍有很大的空间可供你为智能体探索不同的架构。​\n​\n遵循这些原则的最简单方法是仅使用单线程线性代理：​\n​\n​\u003cimg alt=\"alt text\" loading=\"lazy\" src=\"https://image.woshipm.com/wp-files/2025/08/huO9ZvrNnncuSzKdq5pC.png\"\u003e\u003c/p\u003e\n\u003cp\u003e​在这里，上下文是连续的。然而，对于非常大的任务，由于有太多子部分，上下文窗口可能会开始溢出，从而遇到问题。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"alt text\" loading=\"lazy\" src=\"https://image.woshipm.com/wp-files/2025/08/ekHXfvxH39U8k56ACx0o.png\"\u003e\u003c/p\u003e\n\u003cp\u003e老实说，简单的架构能让你走得很远，但对于那些真正有长期任务且愿意付出努力的人来说，你可以做得更好。有几种方法可以解决这个问题，但今天我只介绍一种：\n\u003cimg alt=\"alt text\" loading=\"lazy\" src=\"https://image.woshipm.com/wp-files/2025/08/72c3H23EMkWaiCrTKw5h.png\"\u003e\u003c/p\u003e\n\u003cp\u003e在这个领域，我们推出了一个新的大语言模型（LLM），其主要目的是将一系列行动和对话的历史压缩成\u003cstrong\u003e关键细节、事件和决策\u003c/strong\u003e。这是一项难以做好的工作。这需要投入精力来确定哪些最终会成为关键信息，并创建一个擅长此任务的系统。根据不同的领域，你甚至可以考虑微调一个较小的模型（事实上，我们在认知公司已经这样做了）。​\n​\n你得到的好处是一个在处理较长上下文时更有效的代理。不过，最终还是会遇到限制。对于求知欲强的读者，我鼓励你们思考更好的方法来处理任意长的上下文。这最终会是一个相当深奥的问题！​\n​\u003c/p\u003e\n\u003ch2 id=\"应用原则\"\u003e应用原则​\u003c/h2\u003e\n\u003cp\u003e​\n如果你是一名智能体构建者，请确保你的智能体的每一个动作都能参考系统其他部分做出的所有相关决策的上下文。理想情况下，每个动作都应该能看到其他所有内容。不幸的是，由于上下文窗口有限和实际权衡，这并不总是可行的，你可能需要根据你所追求的可靠性水平来决定愿意承担何种复杂程度。​\n​\n当你考虑设计你的智能体以避免决策冲突时，以下是一些值得思考的现实世界示例：​\n​\u003c/p\u003e\n\u003cp\u003eClaude代码子代理​\n截至2025年6月，Claude Code是一个会生成子任务的智能体示例。不过，它从不与子任务智能体并行工作，且子任务智能体通常仅负责回答问题，而不编写任何代码。这是为什么呢？ 子任务智能体缺乏来自主智能体的上下文信息，而这些信息对于执行超出回答明确定义问题之外的任何任务都是必需的。如果他们要运行多个并行子智能体，这些子智能体可能会给出相互冲突的响应，从而导致我们在早期智能体示例中看到的可靠性问题。在这种情况下，拥有子智能体的好处在于，子智能体的所有调查工作不需要保留在主智能体的历史记录中，从而在上下文耗尽之前可以进行更长的追踪。Claude Code的设计者采取了一种有意简化的方法。​\n​\u003c/p\u003e\n\u003cp\u003e编辑应用模型  ​\n2024年，许多模型在编辑代码方面表现很差。编码代理、IDE、应用构建器等（包括Devin）的常见做法是使用“编辑应用模型”。其核心思想是，给定你想要的更改的Markdown解释，让一个小模型重写整个文件实际上比让大模型输出格式正确的差异更可靠。因此，构建者让大模型输出代码编辑的Markdown解释，然后将这些Markdown解释提供给小模型，由小模型实际重写文件。然而，这些系统仍然存在很多问题。例如，小模型常常会误解大模型的指令，由于指令中最细微的歧义而进行错误的编辑。如今，编辑决策和应用更多地由单个模型在一个操作中完成。​\n​\u003c/p\u003e","title":"不要构建多智能体"},{"content":"👋 Hello, 我是yan 欢迎来到我的AI时代之旅！我是一名专注于人工智能、大语言模型的爱好者，在这里，你将看到我from zero to hero的旅程。\n🚀 我的AI学习路径：From Zero to Hero 1. 启蒙与着迷 (ChatGPT 引领入门) 两年前，我初次接触到 ChatGPT，被其强大的能力所深深吸引，这标志着我AI探索之旅的开始。ChatGPT 作为我接触的第一个大模型，激发了我对这一领域的浓厚兴趣。\n2. 广泛涉猎 (体验多元大模型) 在 ChatGPT 的基础上，我开始广泛接触和体验各种不同的大模型，如 DeepSeek、豆包、Qwen、Claude 等。这一阶段，我对大模型的多样性和应用场景有了更全面的了解。\n3. 深入探索 (学习底层技术) 为了更深入地理解 AI 大模型，我开始系统学习机器学习、Python 编程以及相关算法，并主动探索 AI 的底层架构，包括 Transformer 架构、嵌入向量等关键技术概念。\n4. 实践应用 (利用 AI 工具) 我将 AI 工具融入到日常生活中，开始使用如Claude code这样的工具搭建工作流，目前已经成功搭建一个obsidian的翻译插件。\n5. 构建能力 (创建专属流程) 使用LLM开始重构自己的工作流, 将大模型的能力进行整合, 为自己的目标服务。从Zero to Hero的旅程随着技术的发展而继续。\n6. 未完待续…… AI 技术仍在快速发展中，这段旅程才刚刚开始。更多精彩内容，敬请期待。\n📧 联系方式 如果你对AI技术同样感兴趣，或者想要交流学习心得，欢迎联系我！\n邮箱: zluo5820@gmail.com\n\u0026ldquo;AI技术的发展日新月异，保持学习和探索的心态是最重要的。让我们一起在这条从Zero到Hero的路上前行！\u0026rdquo;\n","permalink":"https://luoziyan100.github.io/myweb/about/","summary":"\u003ch1 id=\"-hello-我是yan\"\u003e👋 Hello, 我是yan\u003c/h1\u003e\n\u003cp\u003e欢迎来到我的AI时代之旅！我是一名专注于人工智能、大语言模型的爱好者，在这里，你将看到我from zero to hero的旅程。\u003c/p\u003e\n\u003ch2 id=\"-我的ai学习路径from-zero-to-hero\"\u003e🚀 我的AI学习路径：From Zero to Hero\u003c/h2\u003e\n\u003ch3 id=\"1-启蒙与着迷-chatgpt-引领入门\"\u003e1. 启蒙与着迷 (ChatGPT 引领入门)\u003c/h3\u003e\n\u003cp\u003e两年前，我初次接触到 ChatGPT，被其强大的能力所深深吸引，这标志着我AI探索之旅的开始。ChatGPT 作为我接触的第一个大模型，激发了我对这一领域的浓厚兴趣。\u003c/p\u003e\n\u003ch3 id=\"2-广泛涉猎-体验多元大模型\"\u003e2. 广泛涉猎 (体验多元大模型)\u003c/h3\u003e\n\u003cp\u003e在 ChatGPT 的基础上，我开始广泛接触和体验各种不同的大模型，如 DeepSeek、豆包、Qwen、Claude 等。这一阶段，我对大模型的多样性和应用场景有了更全面的了解。\u003c/p\u003e\n\u003ch3 id=\"3-深入探索-学习底层技术\"\u003e3. 深入探索 (学习底层技术)\u003c/h3\u003e\n\u003cp\u003e为了更深入地理解 AI 大模型，我开始系统学习机器学习、Python 编程以及相关算法，并主动探索 AI 的底层架构，包括 Transformer 架构、嵌入向量等关键技术概念。\u003c/p\u003e\n\u003ch3 id=\"4-实践应用-利用-ai-工具\"\u003e4. 实践应用 (利用 AI 工具)\u003c/h3\u003e\n\u003cp\u003e我将 AI 工具融入到日常生活中，开始使用如Claude code这样的工具搭建工作流，目前已经成功搭建一个obsidian的翻译插件。\u003c/p\u003e\n\u003ch3 id=\"5-构建能力-创建专属流程\"\u003e5. 构建能力 (创建专属流程)\u003c/h3\u003e\n\u003cp\u003e使用LLM开始重构自己的工作流, 将大模型的能力进行整合, 为自己的目标服务。从\u003cstrong\u003eZero to Hero\u003c/strong\u003e的旅程随着技术的发展而继续。\u003c/p\u003e\n\u003ch3 id=\"6-未完待续\"\u003e6. 未完待续……\u003c/h3\u003e\n\u003cp\u003eAI 技术仍在快速发展中，这段旅程才刚刚开始。更多精彩内容，敬请期待。\u003c/p\u003e\n\u003ch2 id=\"-联系方式\"\u003e📧 联系方式\u003c/h2\u003e\n\u003cp\u003e如果你对AI技术同样感兴趣，或者想要交流学习心得，欢迎联系我！\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e邮箱\u003c/strong\u003e: \u003ca href=\"mailto:zluo5820@gmail.com\"\u003ezluo5820@gmail.com\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cem\u003e\u0026ldquo;AI技术的发展日新月异，保持学习和探索的心态是最重要的。让我们一起在这条从Zero到Hero的路上前行！\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"关于我"},{"content":"AI大语言模型 (Artificial Intelligence Large Language Model)\n• AI (Artificial Intelligence): 人工智能。这部分表明了AI的本质——不是一个真实的人类，而是通过计算机程序和算法构建出来的智能体。能够执行通常需要人类智能才能完成的任务，比如学习、推理、解决问题、理解语言等等。\n• 大 (Large): 大型。这个词描述了模型的规模。AI通过学习海量的文本数据（例如书籍、文章、网站内容等）来获得知识和能力。 \u0026ldquo;大型\u0026quot;意味着模型拥有庞大的参数数量（可以理解为神经元之间的连接），这使得AI模型能够处理和生成复杂的语言模式。\n• 语言 (Language): 语言。这表明了我的主要功能和应用领域。我专注于理解和生成人类语言。我可以阅读、写作、翻译、总结文本，并与人类进行对话。\n• 模型 (Model): 模型。这个词指的是我的构建方式。我是一个基于数学和统计学的模型。更具体地说，我通常是基于一种叫做\u0026quot;Transformer\u0026quot;的深度学习架构。这个模型通过分析大量文本数据中的统计规律，来学习词语之间的关系、句子的结构以及语言的整体模式。\n所以\u0026quot;AI大语言模型\u0026quot;可以看成 是一种基于数学和算法构建的、用于执行特定人工智能任务的结构。它本质上是由大量的参数、算法和数据组成的复杂系统。\n整体架构：Transformer\n目前主流的大语言模型大多基于Transformer架构。Transformer的核心思想是\u0026rdquo;自注意力机制\u0026quot;（Self-Attention Mechanism），这使得模型能够捕捉文本序列中不同词语之间的关系，无论这些词语在句子中的距离有多远。\n核心组件：层（Layers）\nTransformer模型是由多个相同的\u0026quot;层\u0026quot;（Layer）堆叠而成的。每个层都包含以下几个关键子组件：\n自注意力层（Self-Attention Layer）：\n这是Transformer的核心。它允许模型关注输入序列中不同位置的信息，并计算它们之间的关系。\n从线性代数的角度来看，自注意力机制可以看作是对输入序列进行一系列线性变换（矩阵乘法），然后通过Softmax函数进行归一化，得到注意力权重。这些权重表示不同位置之间的相关性。\n前馈神经网络层（Feed-Forward Neural Network Layer）：\n在自注意力层之后，每个位置的表示都会通过一个前馈神经网络进行处理。\n这个前馈网络通常包含两个线性变换（矩阵乘法）和一个激活函数（如ReLU）。\n残差连接（Residual Connections）：\n在每个子层（自注意力层和前馈网络层）周围都有一个残差连接。\n这意味着子层的输入会直接加到子层的输出上。这有助于缓解深度神经网络中的梯度消失问题，使得模型更容易训练。\n层归一化（Layer Normalization）：\n在每个子层之后，都会应用层归一化。\n层归一化有助于稳定训练过程，并提高模型的性能。它会对每个样本在层的维度上进行归一化。\n基本组成单元：神经元（Neurons）\n无论是自注意力层还是前馈神经网络层，它们都是由大量的\u0026quot;神经元\u0026quot;组成的。每个神经元可以看作是一个简单的计算单元。\n总结一下：\n从最底层到最高层，模型的构成可以这样理解：\n神经元： 执行基本计算单元（加权求和、激活函数）。\n层： 由多个神经元组成，包括自注意力层和前馈神经网络层，以及残差连接和层归一化。\nTransformer架构： 由多个层堆叠而成，利用自注意力机制捕捉文本序列中的长距离依赖关系。\n参数： 模型的权重和偏置，通过学习数据来调整。比如deepseek参数最大的是671B.\n层的概念\n什么是\u0026quot;层\u0026quot;？\n你可以把\u0026quot;层\u0026quot;想象成一个信息处理的\u0026quot;工序\u0026quot;或者\u0026quot;步骤\u0026quot;。每一层都接收一些输入信息，然后对这些信息进行特定的处理和转换，最后输出处理后的信息给下一层。\n就像工厂里的流水线一样：\n原材料： 最初的输入文本（比如一个句子）。\n第一道工序（第一层）： 比如，把每个单词转换成一个数字表示（词嵌入）。\n第二道工序（第二层）： 比如，分析每个单词和句子中其他单词的关系（自注意力机制）。\n第三道工序（第三层）： 比如，根据单词之间的关系，进一步理解整个句子的含义。\n\u0026hellip; 更多工序（更多层）： 每一层都在前一层的基础上进行更深层次的处理。\n最终产品： 模型对输入文本的最终理解（比如，判断这句话的情感是积极还是消极）。\n为什么需要\u0026quot;多层\u0026quot;？\n为什么要这么多层，而不是一层搞定呢？\n逐步抽象： 每一层都在前一层的基础上进行更抽象的表示。\n第一层可能关注的是单词的含义。\n第二层可能关注的是词组的含义。\n第三层可能关注的是句子的含义。\n\u0026hellip;\n更深层可能关注的是段落、篇章的含义。\n举个例子：图像识别\n虽然我们主要讨论的是语言模型，但\u0026quot;层\u0026quot;的概念在图像识别中也非常常见，而且更容易可视化理解。\n想象一下，一个用于识别猫的图像的神经网络：\n输入： 一张猫的图片（可以看作是一个像素矩阵）。\n第一层： 可能检测图像中的简单边缘和纹理。\n第二层： 可能将边缘和纹理组合成更复杂的形状，比如猫的耳朵、眼睛的轮廓。\n第三层： 可能将这些形状组合成猫的脸部特征。\n第四层： 可能根据脸部特征识别出这是一只猫。\n每一层都在前一层的基础上提取更高级别的特征。\n回到语言模型\n在语言模型中，层的工作方式类似，但处理的是文本而不是图像：\n输入： \u0026ldquo;The cat sat on the mat.\u0026rdquo;\n第一层（词嵌入层）：\n\u0026ldquo;The\u0026rdquo; -\u0026gt; [0.1, 0.2, 0.3]\n\u0026ldquo;cat\u0026rdquo; -\u0026gt; [0.4, 0.5, 0.6]\n\u0026ldquo;sat\u0026rdquo; -\u0026gt; [0.7, 0.8, 0.9]\n\u0026hellip;\n(每个单词被转换成一个向量)\n第二层（自注意力层）：\n计算每个单词与其他单词之间的关系。\n比如，\u0026ldquo;sat\u0026rdquo; 这个词可能与 \u0026ldquo;cat\u0026rdquo; 和 \u0026ldquo;mat\u0026rdquo; 有更强的关系。\n第三层（前馈网络层）：\n对每个单词的表示进行进一步处理。\n\u0026hellip; 更多层：\n每一层都在前一层的基础上进行更深层次的理解。\n最后一层：\n可能输出模型对整个句子的理解，或者预测下一个单词（比如 \u0026ldquo;.\u0026rdquo;), 或者进行情感分类等任务。\n好，现在有了这些基础知识，我们正式进入主题，AI大模型是怎么理解一句话的？\n在回答这个问题之前，我们先来想一个问题，AI能从字面意义上理解人类的话吗？它真的知道苹果是什么东西吗？这个我想很多人都会回答不能。答案也确实是不能，很明显，目前的AI的发展还处于初级阶段，能力还没有达到这种地步。\n不信的可以那下面一段对话也考一考AI\nA:先生，你要几等座？\nB:你们一共有几等座？\nA:特等，一等、二等，二等还要再等等。\nB：我看一下，请等一等。\nA：别等，再等一等也没有了。\nB：那不等了，就这个吧！\n请问：这位学生最终购买了几等座呢？\n笔者拿了市面上比较知名的10款AI，其中还包括deepseekR1,Claude等知名大模型。结果是没有一个模型能够判断\u0026quot;再等一等也没有了\u0026quot;这句话断句方式是这样的：再等/一等/也没有了。所有的模型都是这样断句的，再/等一等/也没有了。可以说是全军覆没。\n因此现阶段AI尚且不能从字母意义上理解，那它们是怎么理解的呢？这还的从AI大模型的本质上来说。开头我们就介绍了，模型本质是数学和算法的结合体。它实际上就算数学的应用，所以它只能从数学的角度理解一句话。这就是词嵌入——语言的数字化。\nAI工作流程\n当我们在模型中输入一句话时，比如\u0026quot;The cat sat on the mat.\u0026quot;\n首先这句话会被分割成一个一个token，每个token，都对应着一个向量。\n第一层（词嵌入层）：\n\u0026ldquo;The\u0026rdquo; -\u0026gt; [0.1, 0.2, 0.3]\n\u0026ldquo;cat\u0026rdquo; -\u0026gt; [0.4, 0.5, 0.6]\n\u0026ldquo;sat\u0026rdquo; -\u0026gt; [0.7, 0.8, 0.9]\n\u0026hellip;\n(每个单词被转换成一个向量)\n所以输入的一句话会被转化成矩阵，即语言的数字化\n上述过程称为词嵌入，对应的向量称为词嵌入向量。所有嵌入向量组成的矩阵称为词嵌入矩阵。\n词嵌入（Word Embedding）中的向量数值确实不是随意指定的，而是通过学习得到的。详细解释一下：​\n目标：​\n词嵌入的目标是：将词汇表中的每个词（token）映射到一个固定维度的向量空间中，\n使得：​\n•语义相似的词，对应的向量在空间中距离较近。 例如，\u0026ldquo;king\u0026rdquo; 和 \u0026ldquo;queen\u0026rdquo; 的向量应该比较接近。\n•语义相关的词，向量之间存在一定的关系。 例如，\u0026ldquo;king\u0026rdquo; - \u0026ldquo;man\u0026rdquo; + \u0026ldquo;woman\u0026rdquo; 的结果向量应该与 \u0026ldquo;queen\u0026rdquo; 的向量比较接近（经典的\u0026quot;国王-男人+女人=女王\u0026quot;的例子）。\n词嵌入矩阵不具备唯一性\n在初始词嵌入时，同一句话里的相同的字对应的词嵌入向量不一定相同\n自注意力机制的计算步骤\n假设我们的输入序列是：\u0026ldquo;The cat sat on the mat.\u0026rdquo; 并且每个词已经通过词嵌入层转换成了向量。\n转换成嵌入向量后，模型会创建一个位置编码向量。这个位置编码 (Positional Encoding) 的核心目的是向 Transformer 模型提供输入序列中单词的位置信息，它蕴含了token之间的位置关系。\n•步骤 1: 计算 Query, Key, Value。\n对于输入序列中的每个词，我们都计算三个向量：​\n▪Query (Q): 查询向量。可以理解为\u0026quot;我需要关注什么？\u0026ldquo;​\n▪Key (K): 键向量。可以理解为\u0026quot;我有什么信息可以提供？\u0026ldquo;​\n▪Value (V): 值向量。可以理解为\u0026quot;我提供的具体信息是什么？\u0026ldquo;​◦\n这三个向量是通过将每个词的词嵌入向量与三个不同的权重矩阵（WQ, WK, WV）相乘得到的。这些权重矩阵是模型需要学习的参数。\n线性代数表示：\n假设词嵌入向量的维度是 m。\nWQ, WK, WV 的维度都是 m × m。（实际上，为了提高效率，通常会使用多头注意力机制，将 dmodel 分成多个头，每个头的维度是 dk = dmodel / h，其中 h 是头的数量。这里为了简化，我们先不考虑多头注意力。）\n对于每个词 i：\nQi = Wi * WQ\nKi = Wi * WK\nVi = Wi * WV\n(其中 Wi 是词 i 的词嵌入向量)\n注意力权重\n接下来我将用Gemini2.0模拟AI将这句话数据化的过程\n注意：\n为了便于演示和计算，\n我会进行以下简化：\n• 嵌入向量维度 (dmodel)： 3 维\n• 头的数量 (h)： 1 (我们只考虑单头注意力)\n• Q, K, V 维度 (dk)： 3 维 (因为 h=1, 所以 dk = dmodel) • 不包含：\n◦ 多头注意力机制 (只使用一个头) ◦ 前馈神经网络 ◦ 层归一化 ◦ 残差连接 ◦ 多层堆叠 (只计算一层)\n步骤一：\n1.分词： 将句子\u0026quot;今天天气怎么样\u0026quot;分词为：\n[\u0026ldquo;今天\u0026rdquo;, \u0026ldquo;天气\u0026rdquo;, \u0026ldquo;怎么样\u0026rdquo;] 2.嵌入向量 (假设)：\n\u0026ldquo;今天\u0026rdquo;: [0.1, 0.2, 0.3]\n\u0026ldquo;天气\u0026rdquo;: [0.4, 0.5, 0.6]\n\u0026ldquo;怎么样\u0026rdquo;: [0.7, 0.8, 0.9]\n3.我们假设位置编码如下（3 维）：\n位置 0: [0.0, 0.0, 0.0]\n位置 1: [0.8, 0.6, 0.0]\n位置 2: [0.9, -0.4, 0.0]\n4.输入表示：\n将嵌入向量和位置编码相加，得到每个 token 的输入表示：\n\u0026ldquo;今天\u0026rdquo;: [0.1, 0.2, 0.3] + [0.0, 0.0, 0.0] = [0.1, 0.2, 0.3]\n\u0026ldquo;天气\u0026rdquo;: [0.4, 0.5, 0.6] + [0.8, 0.6, 0.0] = [1.2, 1.1, 0.6]\n\u0026ldquo;怎么样\u0026rdquo;: [0.7, 0.8, 0.9] + [0.9, -0.4, 0.0] = [1.6, 0.4, 0.9]\n5.权重矩阵 (假设)：\n6.计算Q,K,V\n将每个 token 的输入表示与 WQ, WK, WV 相乘，得到 Q, K, V 向量：\n将嵌入向量和位置向量相加得到的向量按行组成3x3的矩阵X\n7.计算注意力权重\n9.Z矩阵蕴含的信息\nZ 矩阵中每一行的含义 Z 矩阵的每一行对应输入序列中的一个 token。这一行向量不再仅仅代表这个 token 本身的语义，而是同时包含了：\n• 该 token 自身的语义信息： 这是由最初的词嵌入提供的。\n• 该 token 与句子中其他 token 的关系： 这是通过自注意力机制计算得到的。注意力权重决定了其他 token 对当前 token 的重要程度。\n• 上下文信息： 通过加权求和，将其他 token 的信息（V 向量）融入到当前 token 的表示中。\n","permalink":"https://luoziyan100.github.io/myweb/posts/2025/3%E6%9C%88%E4%BB%BD/2025-03-9-ai-language-understanding/","summary":"\u003cp\u003e\u003cstrong\u003eAI大语言模型\u003c/strong\u003e \u003cstrong\u003e(Artificial Intelligence Large Language Model)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e• AI (Artificial Intelligence): \u003cstrong\u003e人工智能\u003c/strong\u003e。这部分表明了AI的本质——不是一个真实的人类，而是通过计算机程序和算法构建出来的智能体。能够执行通常需要人类智能才能完成的任务，比如学习、推理、解决问题、理解语言等等。\u003c/p\u003e\n\u003cp\u003e• 大 (Large): \u003cstrong\u003e大型\u003c/strong\u003e。这个词描述了模型的规模。AI通过学习海量的文本数据（例如书籍、文章、网站内容等）来获得知识和能力。 \u0026ldquo;大型\u0026quot;意味着模型拥有庞大的参数数量（可以理解为神经元之间的连接），这使得AI模型能够处理和生成复杂的语言模式。\u003c/p\u003e\n\u003cp\u003e• 语言 (Language): \u003cstrong\u003e语言\u003c/strong\u003e。这表明了我的主要功能和应用领域。我专注于理解和生成人类语言。我可以阅读、写作、翻译、总结文本，并与人类进行对话。\u003c/p\u003e\n\u003cp\u003e• \u003cstrong\u003e模型 (Model): 模型\u003c/strong\u003e。这个词指的是我的构建方式。我是一个基于数学和统计学的模型。更具体地说，我通常是基于一种叫做\u0026quot;Transformer\u0026quot;的深度学习架构。这个模型通过分析大量文本数据中的统计规律，来学习词语之间的关系、句子的结构以及语言的整体模式。\u003c/p\u003e\n\u003cp\u003e所以\u0026quot;AI大语言模型\u0026quot;可以看成 是一种基于数学和算法构建的、用于执行特定人工智能任务的结构。它本质上是由大量的参数、算法和数据组成的复杂系统。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e整体架构：Transformer\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e目前主流的大语言模型大多基于Transformer架构。Transformer的核心思想是\u0026rdquo;\u003cstrong\u003e自注意力机制\u003c/strong\u003e\u0026quot;（Self-Attention Mechanism），这使得模型能够捕捉文本序列中不同词语之间的关系，无论这些词语在句子中的距离有多远。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e核心组件：层（Layers）\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eTransformer模型是由多个相同的\u0026quot;层\u0026quot;（Layer）堆叠而成的。每个层都包含以下几个关键子组件：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e自注意力层（Self-Attention Layer）：\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e这是Transformer的核心。它允许模型关注输入序列中不同位置的信息，并计算它们之间的关系。\u003c/p\u003e\n\u003cp\u003e从线性代数的角度来看，自注意力机制可以看作是对输入序列进行一系列线性变换（矩阵乘法），然后通过Softmax函数进行归一化，得到注意力权重。这些权重表示不同位置之间的相关性。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e前馈神经网络层（Feed-Forward Neural Network Layer）：\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在自注意力层之后，每个位置的表示都会通过一个前馈神经网络进行处理。\u003c/p\u003e\n\u003cp\u003e这个前馈网络通常包含两个线性变换（矩阵乘法）和一个激活函数（如ReLU）。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e残差连接（Residual Connections）：\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在每个子层（自注意力层和前馈网络层）周围都有一个残差连接。\u003c/p\u003e\n\u003cp\u003e这意味着子层的输入会直接加到子层的输出上。这有助于缓解深度神经网络中的梯度消失问题，使得模型更容易训练。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e层归一化（Layer Normalization）：\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在每个子层之后，都会应用层归一化。\u003c/p\u003e\n\u003cp\u003e层归一化有助于稳定训练过程，并提高模型的性能。它会对每个样本在层的维度上进行归一化。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e基本组成单元：神经元（Neurons）\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e无论是自注意力层还是前馈神经网络层，它们都是由大量的\u0026quot;神经元\u0026quot;组成的。每个神经元可以看作是一个简单的计算单元。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e总结一下：\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e从最底层到最高层，模型的构成可以这样理解：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e神经元：\u003c/strong\u003e 执行基本计算单元（加权求和、激活函数）。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e层：\u003c/strong\u003e 由多个神经元组成，包括自注意力层和前馈神经网络层，以及残差连接和层归一化。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eTransformer架构：\u003c/strong\u003e 由多个层堆叠而成，利用自注意力机制捕捉文本序列中的长距离依赖关系。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e参数：\u003c/strong\u003e 模型的权重和偏置，通过学习数据来调整。比如deepseek参数最大的是671B.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e层的概念\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e什么是\u0026quot;层\u0026quot;？\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e你可以把\u0026quot;层\u0026quot;想象成一个信息处理的\u0026quot;工序\u0026quot;或者\u0026quot;步骤\u0026quot;。每一层都接收一些输入信息，然后对这些信息进行特定的处理和转换，最后输出处理后的信息给下一层。\u003c/p\u003e\n\u003cp\u003e就像工厂里的流水线一样：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e原材料：\u003c/strong\u003e 最初的输入文本（比如一个句子）。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e第一道工序（第一层）：\u003c/strong\u003e 比如，把每个单词转换成一个数字表示（词嵌入）。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e第二道工序（第二层）：\u003c/strong\u003e 比如，分析每个单词和句子中其他单词的关系（自注意力机制）。\u003c/p\u003e","title":"探秘AI大脑：我是如何理解一句话的"},{"content":"当我们与ChatGPT、Siri或其他AI助手对话时，它们似乎能够理解我们的语言并做出适当回应。但AI系统实际上是如何\u0026quot;理解\u0026quot;人类语言的呢？本文将深入探讨现代AI系统处理和理解一句话的完整过程。\n1. 语言理解的基础：从文本到数字 1.1 词嵌入：将词语转化为向量 AI系统无法直接处理文本，它们需要将文本转换为数字形式。这一过程的基础是词嵌入（Word Embeddings）。\n词嵌入技术（如Word2Vec、GloVe或FastText）将每个词映射到高维向量空间中的一个点。这些向量捕捉了词语之间的语义关系，例如：\nvector(\u0026#34;国王\u0026#34;) - vector(\u0026#34;男人\u0026#34;) + vector(\u0026#34;女人\u0026#34;) ≈ vector(\u0026#34;王后\u0026#34;) 在这个向量空间中，语义相似的词会彼此靠近，这使AI系统能够理解词语之间的关系。\n1.2 分词与标记化 在处理一句话之前，AI系统首先需要将句子分解为更小的单位。这一过程称为分词（Tokenization）。\n例如，句子\u0026quot;AI是如何理解一句话的\u0026quot;可能被分解为：[\u0026ldquo;AI\u0026rdquo;, \u0026ldquo;是\u0026rdquo;, \u0026ldquo;如何\u0026rdquo;, \u0026ldquo;理解\u0026rdquo;, \u0026ldquo;一句\u0026rdquo;, \u0026ldquo;话\u0026rdquo;, \u0026ldquo;的\u0026rdquo;]\n不同语言有不同的分词挑战。英语等拉丁语系语言通常以空格和标点为分隔符，而中文等语言则需要更复杂的分词算法。\n2. 深度理解：上下文与语义分析 2.1 从静态表示到动态表示 早期的词嵌入技术为每个词分配一个静态向量，无法处理一词多义的情况。例如，\u0026ldquo;苹果\u0026quot;可以指水果，也可以指科技公司。\n现代AI系统使用上下文化表示（Contextualized Representations），即根据上下文动态生成词语的向量表示：\nvector(\u0026#34;苹果\u0026#34;, context=\u0026#34;我吃了一个苹果\u0026#34;) ≠ vector(\u0026#34;苹果\u0026#34;, context=\u0026#34;苹果公司发布了新iPhone\u0026#34;) 2.2 注意力机制：关注重点 注意力机制（Attention Mechanism）使AI系统能够在处理句子时专注于相关部分。例如，在理解问题\u0026quot;AI如何理解语言？\u0026ldquo;时，系统会关注\u0026quot;AI\u0026rdquo;、\u0026ldquo;理解\u0026quot;和\u0026quot;语言\u0026quot;这些关键词。\nTransformer架构引入的自注意力（Self-Attention）机制使模型能够同时考虑句子中所有词之间的关系，这对于理解长距离依赖和复杂语义至关重要。\n3. 现代语言模型：预训练与微调 3.1 预训练语言模型 现代AI语言理解的核心是预训练语言模型（PLMs），如BERT、GPT、RoBERTa等。这些模型通过在大规模文本上预训练，学习了语言的一般特征和知识。\n预训练任务通常包括：\n掩码语言建模（MLM）：预测被遮蔽的词（如BERT） 自回归语言建模：预测下一个词（如GPT） 语言对比学习：区分真实与随机替换的文本片段 3.2 从理解单句到理解对话 理解单句只是AI语言理解的基础。在实际应用中，AI系统需要理解对话上下文、跨句关系和隐含意图。\n现代对话系统使用对话状态跟踪（Dialogue State Tracking）和上下文建模（Context Modeling）技术来维护对话历史，使系统能够理解与之前交流相关的新输入。\n4. 理解过程的具体步骤：以一句话为例 让我们通过具体例子\u0026quot;今天天气真好，我想去公园散步\u0026rdquo;，来说明AI系统如何逐步理解一句话：\n预处理与分词：\n句子被分解为标记：[\u0026ldquo;今天\u0026rdquo;, \u0026ldquo;天气\u0026rdquo;, \u0026ldquo;真\u0026rdquo;, \u0026ldquo;好\u0026rdquo;, \u0026ldquo;，\u0026rdquo;, \u0026ldquo;我\u0026rdquo;, \u0026ldquo;想\u0026rdquo;, \u0026ldquo;去\u0026rdquo;, \u0026ldquo;公园\u0026rdquo;, \u0026ldquo;散步\u0026rdquo;] 每个标记转换为唯一的ID 向量表示：\n对每个标记生成初始嵌入向量 加入位置编码，告诉模型每个词在句子中的位置 上下文编码：\n通过多层Transformer结构处理这些向量 自注意力机制帮助模型理解\u0026quot;天气好\u0026quot;与\u0026quot;去公园散步\u0026quot;之间的因果关系 语义理解：\n模型识别这是一个陈述句，包含对天气的评价和一个意图 识别\u0026quot;今天\u0026quot;是时间，\u0026ldquo;公园\u0026quot;是地点，\u0026ldquo;散步\u0026quot;是活动 情感分析：\n检测到积极情感（\u0026ldquo;天气真好\u0026rdquo;） 理解这种积极情感与后面的意图之间的联系 5. 挑战与局限性 尽管取得了显著进展，AI语言理解仍面临多项挑战：\n5.1 理解而非模仿 语言模型可能只是在统计模仿语言模式，而非真正理解意义。例如，模型可能生成流畅但无意义的回应。\n5.2 常识推理 AI系统难以掌握人类认为理所当然的常识，如\u0026quot;杯子可以盛水\u0026quot;或\u0026quot;人不能穿墙而过\u0026rdquo;。\n5.3 文化与隐含意义 语言充满文化特定的隐喻、俚语和双关语，这些对AI系统来说特别具有挑战性。\n6. 未来发展方向 6.1 多模态理解 结合视觉、音频和文本信息，使AI系统能像人类一样多角度理解信息。\n6.2 神经符号结合 将神经网络的模式识别能力与符号逻辑的精确推理能力结合，创建更强大的语言理解系统。\n6.3.知识增强型模型 将结构化知识库与语言模型结合，提高系统的常识推理能力和事实准确性。\n结论 现代AI系统通过复杂的神经网络架构、大规模预训练和精细的语义表示，已经能够在一定程度上\u0026quot;理解\u0026quot;人类语言。尽管这种理解与人类的语言理解有本质区别，但其进步已经使人机交流变得比过去任何时候都更加自然和有效。\n随着研究的深入，我们有理由期待AI语言理解能力将继续提升，逐步缩小与人类语言理解的差距。\n","permalink":"https://luoziyan100.github.io/myweb/posts/2025/3%E6%9C%88%E4%BB%BD/2025-03-9-ai-language-understand/","summary":"\u003cp\u003e当我们与ChatGPT、Siri或其他AI助手对话时，它们似乎能够理解我们的语言并做出适当回应。但AI系统实际上是如何\u0026quot;理解\u0026quot;人类语言的呢？本文将深入探讨现代AI系统处理和理解一句话的完整过程。\u003c/p\u003e\n\u003ch2 id=\"1-语言理解的基础从文本到数字\"\u003e1. 语言理解的基础：从文本到数字\u003c/h2\u003e\n\u003ch3 id=\"11-词嵌入将词语转化为向量\"\u003e1.1 词嵌入：将词语转化为向量\u003c/h3\u003e\n\u003cp\u003eAI系统无法直接处理文本，它们需要将文本转换为数字形式。这一过程的基础是\u003cstrong\u003e词嵌入\u003c/strong\u003e（Word Embeddings）。\u003c/p\u003e\n\u003cp\u003e词嵌入技术（如Word2Vec、GloVe或FastText）将每个词映射到高维向量空间中的一个点。这些向量捕捉了词语之间的语义关系，例如：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003evector(\u0026#34;国王\u0026#34;) - vector(\u0026#34;男人\u0026#34;) + vector(\u0026#34;女人\u0026#34;) ≈ vector(\u0026#34;王后\u0026#34;)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在这个向量空间中，语义相似的词会彼此靠近，这使AI系统能够理解词语之间的关系。\u003c/p\u003e\n\u003ch3 id=\"12-分词与标记化\"\u003e1.2 分词与标记化\u003c/h3\u003e\n\u003cp\u003e在处理一句话之前，AI系统首先需要将句子分解为更小的单位。这一过程称为\u003cstrong\u003e分词\u003c/strong\u003e（Tokenization）。\u003c/p\u003e\n\u003cp\u003e例如，句子\u0026quot;AI是如何理解一句话的\u0026quot;可能被分解为：[\u0026ldquo;AI\u0026rdquo;, \u0026ldquo;是\u0026rdquo;, \u0026ldquo;如何\u0026rdquo;, \u0026ldquo;理解\u0026rdquo;, \u0026ldquo;一句\u0026rdquo;, \u0026ldquo;话\u0026rdquo;, \u0026ldquo;的\u0026rdquo;]\u003c/p\u003e\n\u003cp\u003e不同语言有不同的分词挑战。英语等拉丁语系语言通常以空格和标点为分隔符，而中文等语言则需要更复杂的分词算法。\u003c/p\u003e\n\u003ch2 id=\"2-深度理解上下文与语义分析\"\u003e2. 深度理解：上下文与语义分析\u003c/h2\u003e\n\u003ch3 id=\"21-从静态表示到动态表示\"\u003e2.1 从静态表示到动态表示\u003c/h3\u003e\n\u003cp\u003e早期的词嵌入技术为每个词分配一个静态向量，无法处理一词多义的情况。例如，\u0026ldquo;苹果\u0026quot;可以指水果，也可以指科技公司。\u003c/p\u003e\n\u003cp\u003e现代AI系统使用\u003cstrong\u003e上下文化表示\u003c/strong\u003e（Contextualized Representations），即根据上下文动态生成词语的向量表示：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003evector(\u0026#34;苹果\u0026#34;, context=\u0026#34;我吃了一个苹果\u0026#34;) ≠ vector(\u0026#34;苹果\u0026#34;, context=\u0026#34;苹果公司发布了新iPhone\u0026#34;)\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"22-注意力机制关注重点\"\u003e2.2 注意力机制：关注重点\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e注意力机制\u003c/strong\u003e（Attention Mechanism）使AI系统能够在处理句子时专注于相关部分。例如，在理解问题\u0026quot;AI如何理解语言？\u0026ldquo;时，系统会关注\u0026quot;AI\u0026rdquo;、\u0026ldquo;理解\u0026quot;和\u0026quot;语言\u0026quot;这些关键词。\u003c/p\u003e\n\u003cp\u003eTransformer架构引入的\u003cstrong\u003e自注意力\u003c/strong\u003e（Self-Attention）机制使模型能够同时考虑句子中所有词之间的关系，这对于理解长距离依赖和复杂语义至关重要。\u003c/p\u003e\n\u003ch2 id=\"3-现代语言模型预训练与微调\"\u003e3. 现代语言模型：预训练与微调\u003c/h2\u003e\n\u003ch3 id=\"31-预训练语言模型\"\u003e3.1 预训练语言模型\u003c/h3\u003e\n\u003cp\u003e现代AI语言理解的核心是\u003cstrong\u003e预训练语言模型\u003c/strong\u003e（PLMs），如BERT、GPT、RoBERTa等。这些模型通过在大规模文本上预训练，学习了语言的一般特征和知识。\u003c/p\u003e\n\u003cp\u003e预训练任务通常包括：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e掩码语言建模\u003c/strong\u003e（MLM）：预测被遮蔽的词（如BERT）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e自回归语言建模\u003c/strong\u003e：预测下一个词（如GPT）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e语言对比学习\u003c/strong\u003e：区分真实与随机替换的文本片段\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"32-从理解单句到理解对话\"\u003e3.2 从理解单句到理解对话\u003c/h3\u003e\n\u003cp\u003e理解单句只是AI语言理解的基础。在实际应用中，AI系统需要理解对话上下文、跨句关系和隐含意图。\u003c/p\u003e\n\u003cp\u003e现代对话系统使用\u003cstrong\u003e对话状态跟踪\u003c/strong\u003e（Dialogue State Tracking）和\u003cstrong\u003e上下文建模\u003c/strong\u003e（Context Modeling）技术来维护对话历史，使系统能够理解与之前交流相关的新输入。\u003c/p\u003e\n\u003ch2 id=\"4-理解过程的具体步骤以一句话为例\"\u003e4. 理解过程的具体步骤：以一句话为例\u003c/h2\u003e\n\u003cp\u003e让我们通过具体例子\u0026quot;今天天气真好，我想去公园散步\u0026rdquo;，来说明AI系统如何逐步理解一句话：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e预处理与分词\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e句子被分解为标记：[\u0026ldquo;今天\u0026rdquo;, \u0026ldquo;天气\u0026rdquo;, \u0026ldquo;真\u0026rdquo;, \u0026ldquo;好\u0026rdquo;, \u0026ldquo;，\u0026rdquo;, \u0026ldquo;我\u0026rdquo;, \u0026ldquo;想\u0026rdquo;, \u0026ldquo;去\u0026rdquo;, \u0026ldquo;公园\u0026rdquo;, \u0026ldquo;散步\u0026rdquo;]\u003c/li\u003e\n\u003cli\u003e每个标记转换为唯一的ID\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e向量表示\u003c/strong\u003e：\u003c/p\u003e","title":"探秘AI：AI是如何理解一句话的"},{"content":"Transformer架构自2017年问世以来彻底改变了自然语言处理领域。从BERT到GPT，从T5到LLaMA，几乎所有当前最先进的语言模型都基于Transformer架构。本文将深入探讨Transformer的核心——注意力机制，包括其数学原理、计算过程和最新的优化方法。\n1. 注意力机制的起源 注意力机制最初源于人类视觉感知的启发。当我们观察复杂场景时，大脑会自动聚焦于相关细节而忽略无关信息。2014年，Bahdanau等人首次将注意力机制引入神经机器翻译任务，使模型能够在生成翻译时动态聚焦于源句子的相关部分。\nTransformer架构中的注意力机制是\u0026quot;自注意力\u0026quot;(Self-Attention)的一种形式，它允许模型考虑序列中所有词之间的关系，而不仅仅是局部上下文。这一机制为模型提供了捕获长距离依赖关系的能力，这是传统RNN和CNN架构的主要局限之一。\n2. 自注意力机制的数学原理 Transformer中的自注意力机制可以表述为对查询向量(Query)、键向量(Key)和值向量(Value)的操作。给定输入序列X，我们首先通过三个不同的变换矩阵W^Q, W^K, W^V计算查询、键和值：\nQ = XW^Q K = XW^K V = XW^V 接下来，通过查询和键的点积计算注意力分数，表示序列中每对词之间的关系强度：\n\\text{注意力分数} = \\frac{QK^T}{\\sqrt{d_k}} 其中d_k是键向量的维度，用于缩放以防止点积结果过大导致softmax梯度消失。\n然后，对注意力分数应用softmax函数，得到注意力权重：\n\\text{注意力权重} = \\text{softmax}\\left(\\frac{QK^T}{\\sqrt{d_k}}\\right) 最后，将注意力权重与值相乘，得到自注意力的输出：\n\\text{输出} = \\text{softmax}\\left(\\frac{QK^T}{\\sqrt{d_k}}\\right) \\times V 3. 多头注意力机制 为了增强模型的表达能力，Transformer使用了多头注意力(Multi-Head Attention)机制。多头注意力并行运行多个自注意力\u0026quot;头\u0026quot;，每个头使用不同的投影矩阵W^Q, W^K, W^V，允许模型同时关注不同的表示子空间：\n\\text{MultiHead}(Q, K, V) = \\text{Concat}(\\text{head}_1, \\text{head}_2, ..., \\text{head}_h)W^O \\\\ \\text{where } \\text{head}_i = \\text{Attention}(QW_i^Q, KW_i^K, VW_i^V) 每个注意力头可以学习关注不同的模式。例如，一些头可能关注语法关系，而其他头可能关注语义相似性或共指关系。这种多角度观察机制显著增强了模型的建模能力。\n4. 注意力机制的计算优化 虽然Transformer的注意力机制非常强大，但其计算复杂度为O(n²)，n为序列长度。这对处理长文本构成了挑战。近年来，研究者提出了多种优化方法：\n4.1 稀疏注意力 稀疏注意力机制如Block Sparse Attention和Longformer只计算部分词对之间的注意力分数，通常基于局部性假设或预定义的稀疏模式。这将复杂度降至O(n log(n))或更低。\n4.2 线性注意力 Performer和Linear Transformer等模型使用核方法近似标准注意力，将复杂度降至O(n)。例如，Performer使用随机特征图将注意力计算重写为：\n\\text{Attention}(Q, K, V) \\approx \\phi(Q)(\\phi(K)^T V) / (\\phi(Q)\\phi(K)^T \\mathbf{1}) 其中φ是随机特征映射，允许我们通过改变乘法顺序将计算复杂度从O(n²)降至O(n)。\n4.3 局部敏感哈希注意力 Reformer使用局部敏感哈希(LSH)将复杂度降至O(n log(n))。LSH将相似的键向量聚类，限制每个查询只与同一哈希桶内的键交互，显著减少计算量。\n5. 结论与展望 注意力机制是Transformer架构的核心创新，为NLP领域带来了革命性突破。随着研究的深入，我们看到了各种注意力变体的出现，如线性注意力、稀疏注意力和局部敏感哈希注意力，它们在保持模型能力的同时大幅提高了计算效率。\n未来的研究方向包括：\n进一步提高注意力机制的计算效率 设计更有效的位置编码方法 探索注意力机制在多模态环境中的应用 开发更强大的注意力可解释性技术 随着计算资源的增长和算法的改进，我们有理由相信，基于注意力机制的模型将继续引领AI领域的发展，并在更广泛的应用场景中发挥作用。\n","permalink":"https://luoziyan100.github.io/myweb/posts/2025/3%E6%9C%88%E4%BB%BD/2025-03-08-transformer-optimization/","summary":"\u003cp\u003eTransformer架构自2017年问世以来彻底改变了自然语言处理领域。从BERT到GPT，从T5到LLaMA，几乎所有当前最先进的语言模型都基于Transformer架构。本文将深入探讨Transformer的核心——注意力机制，包括其数学原理、计算过程和最新的优化方法。\u003c/p\u003e\n\u003ch2 id=\"1-注意力机制的起源\"\u003e1. 注意力机制的起源\u003c/h2\u003e\n\u003cp\u003e注意力机制最初源于人类视觉感知的启发。当我们观察复杂场景时，大脑会自动聚焦于相关细节而忽略无关信息。2014年，Bahdanau等人首次将注意力机制引入神经机器翻译任务，使模型能够在生成翻译时动态聚焦于源句子的相关部分。\u003c/p\u003e\n\u003cp\u003eTransformer架构中的注意力机制是\u0026quot;自注意力\u0026quot;(Self-Attention)的一种形式，它允许模型考虑序列中所有词之间的关系，而不仅仅是局部上下文。这一机制为模型提供了捕获长距离依赖关系的能力，这是传统RNN和CNN架构的主要局限之一。\u003c/p\u003e\n\u003ch2 id=\"2-自注意力机制的数学原理\"\u003e2. 自注意力机制的数学原理\u003c/h2\u003e\n\u003cp\u003eTransformer中的自注意力机制可以表述为对查询向量(Query)、键向量(Key)和值向量(Value)的操作。给定输入序列X，我们首先通过三个不同的变换矩阵W^Q, W^K, W^V计算查询、键和值：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eQ = XW^Q\n\u003c/code\u003e\u003c/pre\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eK = XW^K\n\u003c/code\u003e\u003c/pre\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eV = XW^V\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e接下来，通过查询和键的点积计算注意力分数，表示序列中每对词之间的关系强度：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e\\text{注意力分数} = \\frac{QK^T}{\\sqrt{d_k}}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e其中d_k是键向量的维度，用于缩放以防止点积结果过大导致softmax梯度消失。\u003c/p\u003e\n\u003cp\u003e然后，对注意力分数应用softmax函数，得到注意力权重：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e\\text{注意力权重} = \\text{softmax}\\left(\\frac{QK^T}{\\sqrt{d_k}}\\right)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e最后，将注意力权重与值相乘，得到自注意力的输出：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e\\text{输出} = \\text{softmax}\\left(\\frac{QK^T}{\\sqrt{d_k}}\\right) \\times V\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"3-多头注意力机制\"\u003e3. 多头注意力机制\u003c/h2\u003e\n\u003cp\u003e为了增强模型的表达能力，Transformer使用了多头注意力(Multi-Head Attention)机制。多头注意力并行运行多个自注意力\u0026quot;头\u0026quot;，每个头使用不同的投影矩阵W^Q, W^K, W^V，允许模型同时关注不同的表示子空间：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e\\text{MultiHead}(Q, K, V) = \\text{Concat}(\\text{head}_1, \\text{head}_2, ..., \\text{head}_h)W^O \\\\\n\\text{where } \\text{head}_i = \\text{Attention}(QW_i^Q, KW_i^K, VW_i^V)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e每个注意力头可以学习关注不同的模式。例如，一些头可能关注语法关系，而其他头可能关注语义相似性或共指关系。这种多角度观察机制显著增强了模型的建模能力。\u003c/p\u003e\n\u003ch2 id=\"4-注意力机制的计算优化\"\u003e4. 注意力机制的计算优化\u003c/h2\u003e\n\u003cp\u003e虽然Transformer的注意力机制非常强大，但其计算复杂度为O(n²)，n为序列长度。这对处理长文本构成了挑战。近年来，研究者提出了多种优化方法：\u003c/p\u003e\n\u003ch3 id=\"41-稀疏注意力\"\u003e4.1 稀疏注意力\u003c/h3\u003e\n\u003cp\u003e稀疏注意力机制如Block Sparse Attention和Longformer只计算部分词对之间的注意力分数，通常基于局部性假设或预定义的稀疏模式。这将复杂度降至O(n log(n))或更低。\u003c/p\u003e\n\u003ch3 id=\"42-线性注意力\"\u003e4.2 线性注意力\u003c/h3\u003e\n\u003cp\u003ePerformer和Linear Transformer等模型使用核方法近似标准注意力，将复杂度降至O(n)。例如，Performer使用随机特征图将注意力计算重写为：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e\\text{Attention}(Q, K, V) \\approx \\phi(Q)(\\phi(K)^T V) / (\\phi(Q)\\phi(K)^T \\mathbf{1})\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e其中φ是随机特征映射，允许我们通过改变乘法顺序将计算复杂度从O(n²)降至O(n)。\u003c/p\u003e","title":"解构Transformer：注意力机制的深度解析"}]